<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--  -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="application/xml+xhtml; charset=UTF-8"/>
<title>enclone help filter</title>
<style type="text/css">
@font-face {
    font-family: "DejaVuSansMono";
    src:
    local("Menlo Regular"),
    url('https://cdn.jsdelivr.net/npm/@deathbeds/jupyterlab-font-dejavu-sans-mono@1.0.0/style/fonts/DejaVuSansMono.woff2')
    format("woff2"),
    url('https://cdn.jsdelivr.net/npm/dejavu-fonts-ttf@2.37.3/ttf/DejaVuSansMono.ttf')
    format("truetype"),
    url('../fonts/DejaVuLGCSansMono.ttf') format("truetype"),
    local("Courier New");
}
@font-face {
    font-family: "DejaVuSansMono";
    font-weight: bold;
    src:
    local("Menlo Bold"),
    url('https://cdn.jsdelivr.net/npm/@deathbeds/jupyterlab-font-dejavu-sans-mono@1.0.0/style/fonts/DejaVuSansMono-Bold.woff2')
    format("woff2"),
    url('https://cdn.jsdelivr.net/npm/dejavu-fonts-ttf@2.37.3/ttf/DejaVuSansMono-Bold.ttf')
    format("truetype"),
    url('../fonts/DejaVuLGCSansMono-Bold.ttf') format("truetype"),
    local("Courier New Bold");
}
</style>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-58278925-3"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){{dataLayer.push(arguments);}}
gtag('js', new Date());
gtag('config', 'UA-58278925-3');
</script>
</head>
<body>

<br>
<img src="../../img/enclone_banner.png" alt="enclone banner" title="enclone banner" width=100% />
<pre style='font-family: "DejaVuSansMono"; line-height: 110%'><span style="font-size: 14px">
<span style="font-weight:bold;">clonotype filtering options</span>

enclone provides filtering by cell, by exact subclonotype, and by clonotype.  This page describes
filtering by clonotype.  These options cause only certain clonotypes to be printed.  See also
"enclone help special", which describes other filtering options.  This page also described
scanning for feature enrichment.

┌─────────────────────┬─────────────────────────────────────────────────────────────────────────┐
│MIN_CELLS=n          │  only show clonotypes having at least n cells                           │
│MAX_CELLS=n          │  only show clonotypes having at most n cells                            │
│CELLS=n              │  only show clonotypes having exactly n cells                            │
├─────────────────────┼─────────────────────────────────────────────────────────────────────────┤
│MIN_UMIS=n           │  only show clonotypes having ≳ n UMIs on some chain on some cell        │
├─────────────────────┼─────────────────────────────────────────────────────────────────────────┤
│MIN_CHAINS=n         │  only show clonotypes having at least n chains                          │
│MAX_CHAINS=n         │  only show clonotypes having at most n chains                           │
│CHAINS=n             │  only show clonotypes having exactly n chains                           │
├─────────────────────┼─────────────────────────────────────────────────────────────────────────┤
│CDR3=&lt;pattern>       │  only show clonotypes having a CDR3 amino acid seq that matches         │
│                     │  the given pattern*, from beginning to end                              │
├─────────────────────┼─────────────────────────────────────────────────────────────────────────┤
│SEG="s_1|...|s_n"    │  only show clonotypes using one of the given reference segment names    │
│SEGN="s_1|...|s_n"   │  only show clonotypes using one of the given reference segment numbers  │
│                     │  both: looks for V, D, J and C segments; double quote only              │
│                     │  needed if n > 1                                                        │
│                     │  For both SEG and SEGN, multiple instances are allowed, and their       │
│                     │  effects are cumulative.                                                │
├─────────────────────┼─────────────────────────────────────────────────────────────────────────┤
│MIN_EXACTS=n         │  only show clonotypes having at least n exact subclonotypes             │
├─────────────────────┼─────────────────────────────────────────────────────────────────────────┤
│VJ=seq               │  only show clonotypes using exactly the given V..J sequence             │
│                     │  (string in alphabet ACGT)                                              │
├─────────────────────┼─────────────────────────────────────────────────────────────────────────┤
│MIN_DATASETS=n       │  only show clonotypes containing cells from at least n datasets         │
│MAX_DATASETS=n       │  only show clonotypes containing cells from at most n datasets          │
│MIN_DATASET_RATIO=n  │  only show clonotypes having at least n cells and for which the ratio   │
│                     │  of the number of cells in the must abundant dataset to the next most   │
│                     │  abundant one is at least n                                             │
├─────────────────────┼─────────────────────────────────────────────────────────────────────────┤
│CDIFF                │  only show clonotypes having a difference in constant region with the   │
│                     │  universal reference                                                    │
├─────────────────────┼─────────────────────────────────────────────────────────────────────────┤
│DEL                  │  only show clonotypes exhibiting a deletion                             │
├─────────────────────┼─────────────────────────────────────────────────────────────────────────┤
│BARCODE=bc1,...,bcn  │  only show clonotypes that use one of the given barcodes; note that such│
│                     │  clonotypes will typically contain cells that are \bold{not} in your    │
│                     │  list; if you want to fully restrict to a list of barcodes you can use  │
│                     │  the \bold{FCELL} option, please see "enclone help special"             │
├─────────────────────┼─────────────────────────────────────────────────────────────────────────┤
│INKT                 │  only show clonotypes for which some exact subclonotype is annotated as │
│                     │  having some iNKT evidence, see <span style="color:#25bc24;">bit.ly/enclone</span> for details              │
├─────────────────────┼─────────────────────────────────────────────────────────────────────────┤
│MAIT                 │  only show clonotypes for which some exact subclonotype is annotated as │
│                     │  having some MAIT evidence, see <span style="color:#25bc24;">bit.ly/enclone</span> for details              │
└─────────────────────┴─────────────────────────────────────────────────────────────────────────┘

* Examples of how to specify CDR3:

Two pattern types are allowed: either regular expressions, or "Levenshtein distance patterns", as
exhibited by examples below.

┌────────────────────────────────────────┬────────────────────────────────────────────────────┐
│CDR3=CARPKSDYIIDAFDIW                   │  have exactly this sequence as a CDR3              │
│CDR3="CARPKSDYIIDAFDIW|CQVWDSSSDHPYVF"  │  have at least one of these sequences as a CDR3    │
│CDR3=".*DYIID.*"                        │  have a CDR3 that contains DYIID inside it         │
│CDR3="CQTWGTGIRVF~3"                    │  CDR3s within Levenshtein distance 3 of CQTWGTGIRVF│
│CDR3="CQTWGTGIRVF~3|CQVWDSSSDHPYVF~2"   │  CDR3s within Levenshtein distance 3 of CQTWGTGIRVF│
│                                        │  or Levenshtein distance 2 of CQVWDSSSDHPYVF       │
└────────────────────────────────────────┴────────────────────────────────────────────────────┘

Note that double quotes should be used if the pattern contains characters other than letters.

A gentle introduction to regular expressions may be found at
https://en.wikipedia.org/wiki/Regular_expression#Basic_concepts, and a precise
specification for the regular expression version used by enclone may be found at
https://docs.rs/regex.

<span style="font-weight:bold;">linear conditions</span>

enclone understands linear conditions of the form
<span style="font-weight:bold;">c1*v1 ± ... ± cn*vn > d</span>
where each ci is a constant, "ci*" may be omitted, each vi is a variable, and d is a constant. 
Blank spaces are ignored.  The > sign may be replaced by >= or ≥ or &lt; or &lt;= or ≤.  Each vi is a
lead variable (see "<span style="font-weight:bold;">enclone help lvars</span>") that represents a origin/donor/tag count or gene/feature
barcode UMI count.  In evaluating the condition, each vi is replaced by the <span style="font-weight:bold;">mean</span> of its values
across all cells in the clonotype.  Because the minus sign - doubles as a hyphen and is used in
some feature names, we allow parentheses around variable names to prevent erroneous parsing, like
this <span style="font-weight:bold;">(IGHV3-7_g) >= 1</span>.

<span style="font-weight:bold;">filtering by linear conditions</span>

enclone has the capability to filter by bounding certain lead variables, using the command-line
argument:
<span style="font-weight:bold;">F="L"</span>
where L is a linear condition (as defined above).  Currently this is limited to the case where the
lead variables have been selected using <span style="font-weight:bold;">LVARS</span> or <span style="font-weight:bold;">LVARSP</span>!  Multiple bounds may be imposed by using
multiple instances of <span style="font-weight:bold;">F=...</span> .

<span style="font-weight:bold;">feature scanning</span>

If gene expression and/or feature barcode data have been generated, enclone can scan all features
to find those that are enriched in certain clonotypes relative to certain other clonotypes.  This
feature is turned on using the command line argument
<span style="font-weight:bold;">SCAN="test,control,threshold"</span>
where each of <span style="font-weight:bold;">test</span>, <span style="font-weight:bold;">control</span> and <span style="font-weight:bold;">threshold</span> are linear conditions as defined above.  Blank spaces
are ignored.  The <span style="font-weight:bold;">test</span> condition defines the "test clonotypes" and the <span style="font-weight:bold;">control</span> condition defines
the "control clonotypes".  Currently, the lead variables in <span style="font-weight:bold;">test</span> and <span style="font-weight:bold;">control</span> must be specified by
<span style="font-weight:bold;">LVARS</span> or <span style="font-weight:bold;">LVARSP</span>!  The <span style="font-weight:bold;">threshold</span> condition is special: it may use only the variables "t" and "c"
that represent the raw UMI count for a particular gene or feature, for the test (t) or control (c)
clonotypes.  To get a meaningful result, you should specify <span style="font-weight:bold;">MIN_CELLS</span> appropriately and manually
examine the test and control clonotypes to make sure that they make sense.

<span style="font-weight:bold;">an example</span>

Suppose that your data are comprised of two origins with datasets
            named pre and post, representing time points relative to some event.  Then
<span style="font-weight:bold;">SCAN="n_post - 10*n_pre >= 0, n_pre - 0.5*n_post >= 0, t - 2*c >= 0.1"</span>
would define the test clonotypes to be those satisfying n_post >= 10*n_pre (so having far more
post cells then pre cells), the control clonotypes to be those satisfying n_pre >= 0.5*n_post (so
having lots of pre cells), and thresholding on t >= 2*c * 0.1, so that the feature must have a bit
more than twice as many UMIs in the test than the control.  The 0.1 is there to exclude noise from
features having very low UMI counts.

Feature scanning is not a proper statistical test.  It is a tool for generating a list of feature
candidates that may then be examined in more detail by rerunning enclone using some of the
detected features as lead variables (appropriately suffixed).  Ultimately the power of the scan is
determined by having "enough" cells in both the test and control sets, and in having those sets
cleanly defined.

Currently feature scanning requires that each dataset have identical features.

</span></pre>
</body>
</html>
