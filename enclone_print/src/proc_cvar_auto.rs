

        // Copyright (c) 2021 10x Genomics, Inc. All rights reserved.
        // This file is auto-generated by the crate enclone_vars, please do not edit.

        use amino::*;
        use enclone_core::defs::*;
        use enclone_core::opt_d::*;
        use enclone_proto::types::*;
        use stats_utils::*;
        use std::cmp::min;
        use std::collections::HashMap;
        use string_utils::*;
        use vdj_ann::refx::RefData;
        use vector_utils::*;

        pub fn proc_cvar_auto(
            j: usize,
            pass: usize,
            var: &String,
            ex: &ExactClonotype,
            mid: usize,
            col: usize,
            u: usize,
            rsi: &ColInfo,
            refdata: &RefData,
            dref: &Vec<DonorReferenceItem>,
            ctl: &EncloneControl,
            extra_args: &Vec<String>,
            pcols_sort: &Vec<String>,
            cx: &mut Vec<Vec<String>>,
            out_data: &mut Vec<HashMap<String, String>>,
            stats: &mut Vec<(String, Vec<String>)>,
        ) -> Result<bool, String> {

            let cvars = &ctl.clono_print_opt.cvars;

            // Set up macros.

            macro_rules! speakc {
                ($u:expr, $col:expr, $var:expr, $val:expr) => {
                    if pass == 2
                        && ((ctl.parseable_opt.pout.len() > 0
                            && (ctl.parseable_opt.pchains == "max"
                                || col < ctl.parseable_opt.pchains.force_usize()))
                            || extra_args.len() > 0)
                    {
                        let mut v = $var.clone();
                        v = v.replace("_Î£", "_sum");
                        v = v.replace("_Î¼", "_mean");
        
                        // Strip escape character sequences from val.  Can happen in notes, maybe
                        // other places.
        
                        let mut val_clean = String::new();
                        let mut chars = Vec::<char>::new();
                        let valx = format!("{}", $val);
                        for c in valx.chars() {
                            chars.push(c);
                        }
                        let mut escaped = false;
                        for l in 0..chars.len() {
                            if chars[l] == '' {
                                escaped = true;
                            }
                            if escaped {
                                if chars[l] == 'm' {
                                    escaped = false;
                                }
                                continue;
                            }
                            val_clean.push(chars[l]);
                        }
        
                        // Proceed.
        
                        let varc = format!("{}{}", v, $col + 1);
                        if pcols_sort.is_empty()
                            || bin_member(&pcols_sort, &varc)
                            || bin_member(&extra_args, &varc)
                        {
                            out_data[$u].insert(varc, val_clean);
                        }
                    }
                };
            }
    
            macro_rules! cvar_stats1 {
                ($i: expr, $var:expr, $val:expr) => {
                    if $i < rsi.cvars[col].len() && cvars.contains(&$var) {
                        cx[col][$i] = $val.clone();
                    }
                    speakc!(u, col, $var, $val);
                    let varc = format!("{}{}", $var, col + 1);
                    stats.push((varc, vec![$val.to_string(); ex.ncells()]));
                };
            }

            // Test variable.

            let val =
            if false {
                String::new()

        } else if var == "aa%" {
let xm = &ex.share[mid]; let mut diffs = 0;
 let mut denom = 0;
 let aa_seq = &xm.aa_mod_indel;
 let mut vref = refdata.refs[xm.v_ref_id].to_ascii_vec();
 if xm.v_ref_id_donor_alt_id.is_some() {
     vref = dref[xm.v_ref_id_donor.unwrap()].nt_sequence.clone();
 }
 let jref = refdata.refs[xm.j_ref_id].to_ascii_vec();
 let z = 3 * aa_seq.len() + 1;
 for p in 0..aa_seq.len() {
     if aa_seq[p] == b'-' {
         diffs += 1;
         denom += 1;
         continue;
     }
     if 3 * p + 3 <= vref.len() - ctl.heur.ref_v_trim {
         denom += 1;
         if aa_seq[p] != codon_to_aa(&vref[3 * p..3 * p + 3]) {
             diffs += 1;
         }
     }
     if 3 * p > z - (jref.len() - ctl.heur.ref_j_trim) + 3 {
         denom += 1;
         if aa_seq[p]
             != codon_to_aa(&jref[jref.len() - (z - 3 * p)..jref.len() - (z - 3 * p) + 3])
         {
             diffs += 1;
         }
     }
 }
 format!("{:.1}", percent_ratio(denom - diffs, denom))

} else if var == "cdiff" {
let cstart = ex.share[mid].j_stop; let clen = ex.share[mid].full_seq.len() - cstart;
 let cid = ex.share[mid].c_ref_id;
 let mut cdiff = String::new();
 let mut ndiffs = 0;
 if cid.is_some() {
     let r = &refdata.refs[cid.unwrap()];
     let mut extra = 0;
     if clen > r.len() {
         extra = clen - r.len();
     }
     for i in 0..min(clen, r.len()) {
         let tb = ex.share[mid].full_seq[cstart + i];
         let rb = r.to_ascii_vec()[i];
         if tb != rb {
             ndiffs += 1;
             if ndiffs <= 5 {
                 cdiff += &format!("{}{}", i, tb as char);
             }
         }
     }
     if ndiffs > 5 {
         cdiff += "...";
     }
     if extra > 0 {
         cdiff += &format!("+{}", extra);
     }
 } else if clen > 0 {
     cdiff = format!("+{}", clen);
 }
 cdiff

} else if var == "d1_name" {
if !ex.share[mid].left {     String::new()
 } else {
     let mut scores = Vec::<f64>::new();
     let mut ds = Vec::<Vec<usize>>::new();
     opt_d(ex, col, u, rsi, refdata, dref, &mut scores, &mut ds, ctl);
     let mut opt = Vec::new();
     if !ds.is_empty() {
         opt = ds[0].clone();
     }
     let mut opt_name = String::new();
     if opt.is_empty() {
         opt_name = "none".to_string();
     } else {
         for i in 0..opt.len() {
             if i > 0 {
                 opt_name += ":";
             }
             opt_name += &refdata.name[opt[i]];
         }
     }
     opt_name
 }



            } else {
                "$UNDEFINED".to_string()
            };
            if val == "$UNDEFINED" {
                return Ok(false);
            } else {
                cvar_stats1![j, var, val];
                return Ok(true);
            }
        }

        