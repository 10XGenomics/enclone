// Copyright (c) 2021 10x Genomics, Inc. All rights reserved.
// This file is auto-generated by the crate enclone_vars, please do not edit.

use amino::*;
// use crate::print_utils1::*;
// use crate::print_utils3::*;
// use enclone_core::align_to_vdj_ref::*;
use enclone_core::defs::*;
// use enclone_core::median::*;
// use enclone_core::opt_d::*;
use enclone_proto::types::*;
use itertools::Itertools;
// use stats_utils::*;
// use std::cmp::min;
use std::collections::HashMap;
use string_utils::*;
use vdj_ann::refx::RefData;
use vector_utils::*;

pub fn proc_lvar_auto(
    i: usize,
    pass: usize,
    var: &String,
    exacts: &Vec<usize>,
    exact_clonotypes: &Vec<ExactClonotype>,
    u: usize,
    rsi: &ColInfo,
    refdata: &RefData,
    ctl: &EncloneControl,
    extra_args: &Vec<String>,
    out_data: &mut Vec<HashMap<String, String>>,
    stats: &mut Vec<(String, Vec<String>)>,
    lvars: &Vec<String>,
    row: &mut Vec<String>,
    fate: &Vec<HashMap<String, String>>,
    dref: &Vec<DonorReferenceItem>,
    varmat: &Vec<Vec<Vec<u8>>>,
) -> Result<bool, String> {
    let clonotype_id = exacts[u];
    let ex = &exact_clonotypes[clonotype_id];
    let mat = &rsi.mat;
    let cols = varmat[0].len();
    let verbose = ctl.gen_opt.row_fill_verbose;

    macro_rules! speak {
        ($u:expr, $var:expr, $val:expr) => {
            if pass == 2 && (ctl.parseable_opt.pout.len() > 0 || extra_args.len() > 0) {
                let mut v = $var.to_string();
                v = v.replace("_Œ£", "_sum");
                v = v.replace("_Œº", "_mean");
                if ctl.parseable_opt.pcols.is_empty()
                    || bin_member(&ctl.parseable_opt.pcols_sortx, &v)
                    || bin_member(&extra_args, &v)
                {
                    out_data[$u].insert(v, $val);
                }
            }
        };
    }

    macro_rules! lvar_stats1 {
        ($i: expr, $var:expr, $val:expr) => {
            if verbose {
                eprint!("lvar {} ==> {}; ", $var, $val);
                eprintln!("$i = {}, lvars.len() = {}", $i, lvars.len());
            }
            if $i < lvars.len() {
                row.push($val)
            }
            if pass == 2 {
                speak!(u, $var.to_string(), $val);
            }
            stats.push(($var.to_string(), vec![$val; ex.ncells()]));
        };
    }

    macro_rules! lvar_stats {
        ($i: expr, $var:expr, $val:expr, $stats: expr) => {
            if verbose {
                eprint!("lvar {} ==> {}; ", $var, $val);
                eprintln!("$i = {}, lvars.len() = {}", $i, lvars.len());
            }
            if $i < lvars.len() {
                row.push($val)
            }
            if pass == 2 {
                speak!(u, $var.to_string(), $val);
            }
            stats.push(($var.to_string(), $stats.clone()));
        };
    }

    let val = if false {
        (String::new(), Vec::<String>::new(), String::new())
    } else if var == "datasets" {
        let mut datasets = Vec::<String>::new();
        for j in 0..ex.clones.len() {
            datasets.push(ctl.origin_info.dataset_id[ex.clones[j][0].dataset_index].clone());
        }
        let mut datasets_unique = datasets.clone();
        unique_sort(&mut datasets_unique);

        (
            format!("{}", datasets_unique.iter().format(",")),
            datasets,
            "cell-exact".to_string(),
        )
    } else if var == "datasets_cell" {
        let mut datasets = Vec::<String>::new();
        for j in 0..ex.clones.len() {
            datasets.push(ctl.origin_info.dataset_id[ex.clones[j][0].dataset_index].clone());
        }
        let mut datasets_unique = datasets.clone();
        unique_sort(&mut datasets_unique);

        let _exact = format!("{}", datasets_unique.iter().format(","));
        (String::new(), datasets, "cell-exact".to_string())
    } else if var == "donors" {
        let mut donors = Vec::<String>::new();
        for j in 0..ex.clones.len() {
            if ex.clones[j][0].donor_index.is_some() {
                donors
                    .push(ctl.origin_info.donor_list[ex.clones[j][0].donor_index.unwrap()].clone());
            } else {
                donors.push("?".to_string());
            }
        }
        let donors_unsorted = donors.clone();
        unique_sort(&mut donors);

        (
            format!("{}", donors.iter().format(",")),
            donors_unsorted,
            "cell-exact".to_string(),
        )
    } else if var == "donors_cell" {
        let mut donors = Vec::<String>::new();
        for j in 0..ex.clones.len() {
            if ex.clones[j][0].donor_index.is_some() {
                donors
                    .push(ctl.origin_info.donor_list[ex.clones[j][0].donor_index.unwrap()].clone());
            } else {
                donors.push("?".to_string());
            }
        }
        let donors_unsorted = donors.clone();
        unique_sort(&mut donors);

        let _exact = format!("{}", donors.iter().format(","));
        (String::new(), donors_unsorted, "cell-exact".to_string())
    } else if var == "dref" {
        let mut diffs = 0;

        for m in 0..cols {
            if mat[m][u].is_some() {
                let r = mat[m][u].unwrap();
                let seq = &ex.share[r].seq_del_amino;
                let mut vref = refdata.refs[rsi.vids[m]].to_ascii_vec();
                if rsi.vpids[m].is_some() {
                    vref = dref[rsi.vpids[m].unwrap()].nt_sequence.clone();
                }
                let jref = refdata.refs[rsi.jids[m]].to_ascii_vec();
                let z = seq.len();
                for p in 0..z {
                    let b = seq[p];
                    if p < vref.len() - ctl.heur.ref_v_trim && b != vref[p] {
                        diffs += 1;
                    }
                    if p >= z - (jref.len() - ctl.heur.ref_j_trim)
                        && b != jref[jref.len() - (z - p)]
                    {
                        diffs += 1;
                    }
                }
            }
        }

        (format!("{}", diffs), Vec::new(), "exact".to_string())
    } else if var == "dref_aa" {
        let mut diffs = 0;
        for m in 0..cols {
            if mat[m][u].is_some() {
                let r = mat[m][u].unwrap();
                let aa_seq = &ex.share[r].aa_mod_indel;
                let mut vref = refdata.refs[rsi.vids[m]].to_ascii_vec();
                if rsi.vpids[m].is_some() {
                    vref = dref[rsi.vpids[m].unwrap()].nt_sequence.clone();
                }
                let jref = refdata.refs[rsi.jids[m]].to_ascii_vec();
                let z = 3 * aa_seq.len() + 1;
                for p in 0..aa_seq.len() {
                    if aa_seq[p] == b'-' {
                        diffs += 1;
                        continue;
                    }
                    if 3 * p + 3 <= vref.len() - ctl.heur.ref_v_trim
                        && aa_seq[p] != codon_to_aa(&vref[3 * p..3 * p + 3])
                    {
                        diffs += 1;
                    }
                    if 3 * p > z - (jref.len() - ctl.heur.ref_j_trim) + 3
                        && aa_seq[p]
                            != codon_to_aa(
                                &jref[jref.len() - (z - 3 * p)..jref.len() - (z - 3 * p) + 3],
                            )
                    {
                        diffs += 1;
                    }
                }
            }
        }

        (format!("{}", diffs), Vec::new(), "exact".to_string())
    } else if var == "filter" {
        let mut fates = Vec::<String>::new();
        for j in 0..ex.clones.len() {
            let mut f = String::new();
            let bc = &ex.clones[j][0].barcode;
            let li = ex.clones[j][0].dataset_index;
            if fate[li].contains_key(&bc.clone()) {
                f = fate[li][&bc.clone()].clone();
                f = f.between(" ", " ").to_string();
            }
            fates.push(f);
        }

        (String::new(), fates, "cell".to_string())
    } else if var == "inkt" {
        let mut s = String::new();
        let alpha_g = ex.share[0].inkt_alpha_chain_gene_match;
        let alpha_j = ex.share[0].inkt_alpha_chain_junction_match;
        let beta_g = ex.share[0].inkt_beta_chain_gene_match;
        let beta_j = ex.share[0].inkt_beta_chain_junction_match;
        if alpha_g || alpha_j {
            s += "ùù∞";
            if alpha_g {
                s += "g";
            }
            if alpha_j {
                s += "j";
            }
        }
        if beta_g || beta_j {
            s += "ùù±";
            if beta_g {
                s += "g";
            }
            if beta_j {
                s += "j";
            }
        }

        (s, Vec::new(), "exact".to_string())
    } else if var == "mait" {
        let mut s = String::new();
        let alpha_g = ex.share[0].mait_alpha_chain_gene_match;
        let alpha_j = ex.share[0].mait_alpha_chain_junction_match;
        let beta_g = ex.share[0].mait_beta_chain_gene_match;
        let beta_j = ex.share[0].mait_beta_chain_junction_match;
        if alpha_g || alpha_j {
            s += "ùù∞";
            if alpha_g {
                s += "g";
            }
            if alpha_j {
                s += "j";
            }
        }
        if beta_g || beta_j {
            s += "ùù±";
            if beta_g {
                s += "g";
            }
            if beta_j {
                s += "j";
            }
        }

        (s, Vec::new(), "exact".to_string())
    } else if var == "nchains" {
        (
            format!("{}", rsi.mat.len()),
            Vec::new(),
            "clono".to_string(),
        )
    } else if var == "nchains_present" {
        (
            format!("{}", exact_clonotypes[exacts[u]].share.len()),
            Vec::new(),
            "exact".to_string(),
        )
    } else if var == "origins" {
        let mut origins = Vec::<String>::new();
        for j in 0..ex.clones.len() {
            if ex.clones[j][0].origin_index.is_some() {
                origins.push(
                    ctl.origin_info.origin_list[ex.clones[j][0].origin_index.unwrap()].clone(),
                );
            } else {
                origins.push("?".to_string());
            }
        }
        let origins_unsorted = origins.clone();
        unique_sort(&mut origins);

        (
            format!("{}", origins.iter().format(",")),
            origins_unsorted,
            "cell-exact".to_string(),
        )
    } else if var == "origins_cell" {
        let mut origins = Vec::<String>::new();
        for j in 0..ex.clones.len() {
            if ex.clones[j][0].origin_index.is_some() {
                origins.push(
                    ctl.origin_info.origin_list[ex.clones[j][0].origin_index.unwrap()].clone(),
                );
            } else {
                origins.push("?".to_string());
            }
        }
        let origins_unsorted = origins.clone();
        unique_sort(&mut origins);

        let _exact = format!("{}", origins.iter().format(","));
        (String::new(), origins_unsorted, "cell-exact".to_string())
    } else {
        (
            "$UNDEFINED".to_string(),
            Vec::<String>::new(),
            String::new(),
        )
    };
    if val.0 == "$UNDEFINED" {
        return Ok(false);
    } else {
        let (exact, cell, level) = &val;
        if level == "cell" && !var.ends_with("_cell") {
            lvar_stats![i, var, String::new(), cell];
            if pass == 2 {
                speak!(u, var, format!("{}", cell.iter().format(POUT_SEP)));
            }
        } else if (exact.len() > 0 && !var.ends_with("_cell")) || cell.len() == 0 {
            lvar_stats1![i, var, exact.to_string()];
        } else if cell.len() > 0 {
            if pass == 2 {
                speak!(u, var, format!("{}", cell.iter().format(POUT_SEP)));
            }
            stats.push((var.to_string(), cell.to_vec()));
        }
        return Ok(true);
    }
}
