// Copyright (c) 2021 10x Genomics, Inc. All rights reserved.

// Read the vars file and export code.  This is a partial implementation.
// Output is {(filename, contents)}.
//
// This writes a temporary file.

use crate::var::parse_variables;
use io_utils::*;
use std::fs::File;
use std::io::{BufWriter, Write};
use std::process::Command;
use string_utils::*;

pub fn export_code(level: usize) -> Vec<(String, String)> {
    // Define code start/stop for cvar_vdj.

    let cvar_vdj_start = r###"

        // Copyright (c) 2021 10x Genomics, Inc. All rights reserved.
        // This file is auto-generated by the crate enclone_vars, please do not edit.

        use amino::*;
        use crate::print_utils1::*;
        use crate::print_utils3::*;
        use enclone_core::align_to_vdj_ref::*;
        use enclone_core::defs::*;
        use enclone_core::median::*;
        use enclone_core::opt_d::*;
        use enclone_proto::types::*;
        use itertools::Itertools;
        use stats_utils::*;
        use std::cmp::min;
        use std::collections::HashMap;
        use string_utils::*;
        use vdj_ann::refx::RefData;
        use vector_utils::*;

        pub fn proc_cvar_auto(
            j: usize,
            pass: usize,
            var: &String,
            ex: &ExactClonotype,
            exacts: &Vec<usize>,
            exact_clonotypes: &Vec<ExactClonotype>,
            mid: usize,
            col: usize,
            u: usize,
            rsi: &ColInfo,
            refdata: &RefData,
            dref: &Vec<DonorReferenceItem>,
            ctl: &EncloneControl,
            extra_args: &Vec<String>,
            pcols_sort: &Vec<String>,
            cx: &mut Vec<Vec<String>>,
            varmat: &Vec<Vec<Vec<u8>>>,
            out_data: &mut Vec<HashMap<String, String>>,
            stats: &mut Vec<(String, Vec<String>)>,
        ) -> Result<bool, String> {

            let cvars = &ctl.clono_print_opt.cvars;

            // Set up macros.

            macro_rules! speakc {
                ($u:expr, $col:expr, $var:expr, $val:expr) => {
                    if pass == 2
                        && ((ctl.parseable_opt.pout.len() > 0
                            && (ctl.parseable_opt.pchains == "max"
                                || col < ctl.parseable_opt.pchains.force_usize()))
                            || extra_args.len() > 0)
                    {
                        let mut v = $var.clone();
                        v = v.replace("_Î£", "_sum");
                        v = v.replace("_Î¼", "_mean");
        
                        // Strip escape character sequences from val.  Can happen in notes, maybe
                        // other places.
        
                        let mut val_clean = String::new();
                        let mut chars = Vec::<char>::new();
                        let valx = format!("{}", $val);
                        for c in valx.chars() {
                            chars.push(c);
                        }
                        let mut escaped = false;
                        for l in 0..chars.len() {
                            if chars[l] == '' {
                                escaped = true;
                            }
                            if escaped {
                                if chars[l] == 'm' {
                                    escaped = false;
                                }
                                continue;
                            }
                            val_clean.push(chars[l]);
                        }
        
                        // Proceed.
        
                        let varc = format!("{}{}", v, $col + 1);
                        if pcols_sort.is_empty()
                            || bin_member(&pcols_sort, &varc)
                            || bin_member(&extra_args, &varc)
                        {
                            out_data[$u].insert(varc, val_clean);
                        }
                    }
                };
            }
    
            // Test variable.

            let val =
            if false {
                (String::new(), Vec::<String>::new())

        "###;

    let cvar_vdj_stop = r###"

            } else {
                ("$UNDEFINED".to_string(), Vec::<String>::new())
            };
            if val.0 == "$UNDEFINED" {
                return Ok(false);
            } else {
                let (exact, cell) = &val;
                let varc = format!("{}{}", var, col + 1);
                if exact.len() > 0 {
                    if j < rsi.cvars[col].len() && cvars.contains(&var) {
                        cx[col][j] = exact.clone();
                    }
                    speakc!(u, col, var, exact);
                    if val.1.is_empty() {
                        stats.push((varc, vec![exact.to_string(); ex.ncells()]));
                    } else {
                        stats.push((varc, cell.to_vec()));
                    }
                } else if cell.len() > 0 {
                    if pass == 2
                        && ((ctl.parseable_opt.pchains == "max"
                            || col < ctl.parseable_opt.pchains.force_usize())
                            || !extra_args.is_empty())
                    {
                        if pcols_sort.is_empty() || bin_member(pcols_sort, &varc) {
                            let vals = format!("{}", cell.iter().format(&POUT_SEP));
                            out_data[u].insert(varc, vals);
                        }
                    }
                }
                return Ok(true);
            }
        }

        "###;

    // Build cvar auto file.

    let actual_out = "enclone_print/src/proc_cvar_auto.rs".to_string();
    let mut temp_out = "enclone_exec/testx/outputs/proc_cvar_auto.rs".to_string();
    let mut vars_loc = "enclone_vars/src/vars".to_string();
    if level == 1 {
        temp_out = format!("../{}", temp_out);
        vars_loc = format!("../{}", vars_loc);
    }
    {
        let mut f = open_for_write_new![&temp_out];
        fwrite!(f, "{}", cvar_vdj_start);
        let vars = std::fs::read_to_string(&vars_loc).unwrap();
        let vars = parse_variables(&vars);
        for v in vars.iter() {
            if v.inputs == "cvar_vdj" {
                // Parse value return lines.

                let mut exact = "String::new()".to_string();
                let mut cell = "Vec::new()".to_string();
                let mut code = v.code.clone();
                let mut lines = Vec::<String>::new();
                for line in code.lines() {
                    lines.push(line.to_string());
                }
                let n = lines.len();
                if n > 0 {
                    let mut sub = 0;
                    for i in (0..lines.len()).rev() {
                        if lines[i].contains("exact: ") {
                            exact = lines[i].after("exact: ").to_string();
                            sub += 1;
                        } else if lines[i].contains("cell: ") {
                            cell = lines[i].after("cell: ").to_string();
                            sub += 1;
                        }
                    }
                    let mut code2 = String::new();
                    for i in 0..lines.len() - sub {
                        code2 += &mut format!("{}\n", lines[i]);
                    }
                    code = code2;
                }
                if v.level == "cell-exact" {
                    assert!(exact.len() > 0);
                    assert!(cell.len() > 0);
                }
                if v.level == "cell" {
                    assert!(cell.len() > 0);
                }

                // Proceed.

                // RESTRICTION 1: only allow cvar_vdj
                let mut upper = false;
                let var = &v.name;
                for c in var.chars() {
                    if c.is_ascii_uppercase() {
                        upper = true;
                    }
                }
                // RESTRICTION 2: don't allow upper case
                if !upper {
                    let mut passes = 1;
                    if v.level == "cell-exact" {
                        passes = 2;
                    }
                    for pass in 1..=passes {
                        if !var.contains('{') {
                            let mut var = var.clone();
                            if pass == 2 {
                                var += "_cell";
                            }
                            fwriteln!(f, r###"}} else if var == "{}" {{"###, var);
                        // RESTRICTION 3: allow only one {} pair
                        } else if !var.after("{").contains("{") {
                            let begin = var.before("{");
                            let mut end = var.after("}").to_string();
                            if pass == 2 {
                                end += "_cell";
                            }
                            let low = var.after("{").before("..").force_usize();
                            let high = var.after("{").between("..", "}");
                            if high.len() > 0 {
                                let high = high.force_usize();
                                fwriteln!(
                                    f,
                                    r###"}} else if var.starts_with("{begin}")
                                    && var.ends_with("{end}")
                                    && var.between2("{begin}", "{end}").parse::<usize>().is_ok()
                                    && var.between2("{begin}", "{end}").force_i64() >= {low}
                                    && var.between2("{begin}", "{end}").force_usize() 
                                       <= {high} {{"###,
                                    begin = begin,
                                    end = end,
                                    low = low,
                                    high = high,
                                );
                            } else {
                                fwriteln!(
                                    f,
                                    r###"}} else if var.starts_with("{begin}")
                                    && var.ends_with("{end}")
                                    && var.between2("{begin}", "{end}").parse::<usize>().is_ok()
                                    && var.between2("{begin}", "{end}").force_i64() 
                                       >= {low} {{"###,
                                    begin = begin,
                                    end = end,
                                    low = low,
                                );
                            }
                            fwriteln!(
                                f,
                                r###"let arg1 = var.between2("{}", "{}").force_usize();"###,
                                begin,
                                end,
                            );
                        }
                        fwriteln!(f, "{}", code);
                        if pass == 1 {
                            fwriteln!(f, "({}, {})", exact, cell);
                        } else {
                            fwriteln!(f, "let _exact = {};", exact); // to circumvent warning
                            fwriteln!(f, "(String::new(), {})", cell);
                        }
                    }
                }
            }
        }
        fwrite!(f, "{}", cvar_vdj_stop);
    }

    // Rustfmt.

    let new = Command::new("rustfmt")
        .arg(&temp_out)
        .output()
        .unwrap_or_else(|_| panic!("{}", "failed to execute rustfmt".to_string()));
    if new.status.code() != Some(0) {
        eprintln!("\nrustfmt failed\n");
        eprintln!(
            "You can observe the problem by typing rustfmt {}.\n",
            temp_out
        );
        std::process::exit(1);
    }
    let f = std::fs::read_to_string(&temp_out).unwrap();
    let mut outs = Vec::<(String, String)>::new();
    outs.push((actual_out, f));
    outs
}
