# Copyright (c) 2021 10X Genomics, Inc. All rights reserved.
#
# This is the start of a variable registry for enclone.  Every variable must specify all the
# following fields, in the same order.  
#
# The exact formatting as exhibited by existing variables # must be followed.  This includes
# indentation.
#
# name:     name of the variable, which may include special strings so as to represent
#           variable classes; this excludes the chain number suffix (1,...) for cvars.
#
#           Upper case characters always define variable class strings.  The following are
#           recognized:
#           BC         user-defined variable from BC or META/bc
#           DATASET    name of a dataset
#           FEATURE    name of a feature
#           INFO       user-defined variable from INFO
#           NAME       name, see n_<name> at enclone help lvars
#           REGA       regular expression for amino acids
#           VARDEF     user-defined variable from VAR_DEF
#
#           Inclusive integer ranges: these have the form {a..b} or {a..} or {..b} or {..}.  Up to
#           three ranges are allowed in a variable.
#
# inputs:   data structures needed as input
#           ex: ExactClonotype = exact subclonotype structure
#           mid: usize = chain id in clonotype
#           refdata
#           fm: gex_info.feature_metrics = feature values by barcode
#           col
#           exacts
#           exact_clonotypes
#           rsi
#
# limits:   limitations on availability of the variable
#
# class:    lvar or cvar
#
# level:    scope of the variable, one of
#           cell, cell-exact, exact, clono, dataset, global
#
# val:      the type of the value, one of
#           positive_integer, float[0,100].precision(1)
#
# doc:      documentation
#
# brief:    brief documentation, for use in compact html tables
#
# page:     reference page
#
# avail:    availability, public or private or ? (temp)
#
# notes:    things to clarify
#
# code:     code for computing the variable value
#           There are one or two special lines at the end with form like
#           exact: <value>
#           where exact can be another keyword.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     BC
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell
val:      string
doc:      TBD
brief:    user-defined variable from BC or META/bc
page:     enclone help input
avail:    public
notes:
code:     let mut r = Vec::<String>::new();
          for l in 0..ex.clones.len() {
              let li = ex.clones[l][0].dataset_index;
              let bc = ex.clones[l][0].barcode.clone();
              let mut val = String::new();
              let alt = &ctl.origin_info.alt_bc_fields[li];
              for j in 0..alt.len() {
                  if alt[j].0 == *var && alt[j].1.contains_key(&bc.clone()) {
                      val = alt[j].1[&bc.clone()].clone();
                  }
              }
              r.push(val);
          }
          cell: r
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     DATASET_barcode
inputs:   ?
limits:   only implemented for parseable output
class:    lvar
level:    cell
val:      string
doc:      TBD
brief:    barcode from the given dataset (or null)
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     DATASET_barcodes
inputs:   ?
limits:   only implemented for parseable output
class:    lvar
level:    exact
val:      string
doc:      TBD
brief:    barcodes from the given dataset
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE
inputs:   ?
limits:
class:    lvar
level:    cell-exact
val:      float
doc:      TBD
brief:    median count for a gene expression or antibody feature
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_%
inputs:   ?
limits:
class:    lvar
level:    cell-exact
val:      float[0,100].precision(1)
doc:      TBD
brief:    median percent of total expression for a particular gene
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_%_cell
inputs:   ?
limits:
class:    lvar
level:    cell
val:      float[0,100].precision(1)
doc:      TBD
brief:    percent of total expression for a particular gene
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_cell
inputs:   ?
limits:
class:    lvar
level:    cell
val:      nonnegative_integer
doc:      TBD
brief:    count for a gene expression or antibody feature
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_cellular_r
inputs:   fm
limits:
class:    lvar
level:    dataset
val:      float[0,100].precision(1)
doc:      For a given feature, the percent of reads that are identified by the
          cellranger pipeline as lying in a cell.
brief:    percent of feature reads in cells, for a given dataset
page:     enclone help display
avail:    ?
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_cellular_u
inputs:   fm
limits:
class:    lvar
level:    dataset
val:      float[0,100].precision(1)
doc:      For a given feature, the percent of UMIs that are identified by the
          cellranger pipeline as lying in a cell.
brief:    percent of feature UMIs in cells, for a given dataset
page:     enclone help display
avail:    ?
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_max
inputs:   ?
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    maximum count for a feature
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_mean
inputs:   ?
limits:
class:    lvar
level:    exact
val:      float
doc:      TBD
brief:    mean count for a feature (same as <code>μ</code> for <code>mean</code>)
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_min
inputs:   ?
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    minimum count for a feature 
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_sum
inputs:   ?
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    sum of counts for a feature (same as <code>Σ</code> for <code>sum</code>)
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_Σ
inputs:   ?
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    sum of counts for a feature (same as <code>sum</code> for <code>Σ</code>)
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_μ
inputs:   ?
limits:
class:    lvar
level:    exact
val:      float
doc:      TBD
brief:    mean count for a feature (same with <code>mean</code> for <code>μ</code>)
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     INFO
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      string
doc:      TBD
brief:    user-defined variable from INFO
page:     enclone help input
avail:    public
notes:
code:     let mut val = String::new();
          for q in 0..ctl.gen_opt.info_fields.len() {
              if *var == ctl.gen_opt.info_fields[q]
                  && ex.share.len() == 2 && ex.share[0].left != ex.share[1].left {
                  let mut tag = String::new();
                  for j in 0..ex.share.len() {
                      if ex.share[j].left {
                          tag += strme(&ex.share[j].seq);
                      }
                  }
                  tag += "_";
                  for j in 0..ex.share.len() {
                      if !ex.share[j].left {
                          tag += strme(&ex.share[j].seq);
                      }
                  }
                  if ctl.gen_opt.info_data.contains_key(&tag) {
                      val = ctl.gen_opt.info_data[&tag][q].clone();
                  }
              }
          }
          exact: val
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     VARDEF
inputs:   ?
limits:
class:    lvar
level:    cell-exact
val:      string
doc:      TBD
brief:    user-defined variable from VAR_DEF
page:     enclone help input
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     aa%
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      float[0,100].precision(1)
doc:      TBD
brief:    amino acid identity with donor reference
page:     enclone help cvars
avail:    public
notes:
code:     let xm = &ex.share[mid];
          let mut diffs = 0;
          let mut denom = 0;
          let aa_seq = &xm.aa_mod_indel;
          let mut vref = refdata.refs[xm.v_ref_id].to_ascii_vec();
          if xm.v_ref_id_donor_alt_id.is_some() {
              vref = dref[xm.v_ref_id_donor.unwrap()].nt_sequence.clone();
          }
          let jref = refdata.refs[xm.j_ref_id].to_ascii_vec();
          let z = 3 * aa_seq.len() + 1;
          for p in 0..aa_seq.len() {
              if aa_seq[p] == b'-' {
                  diffs += 1;
                  denom += 1;
                  continue;
              }
              if 3 * p + 3 <= vref.len() - ctl.heur.ref_v_trim {
                  denom += 1;
                  if aa_seq[p] != codon_to_aa(&vref[3 * p..3 * p + 3]) {
                      diffs += 1;
                  }
              }
              if 3 * p > z - (jref.len() - ctl.heur.ref_j_trim) + 3 {
                  denom += 1;
                  if aa_seq[p]
                      != codon_to_aa(&jref[jref.len() - (z - 3 * p)..jref.len() - (z - 3 * p) + 3])
                  {
                      diffs += 1;
                  }
              }
          }
          exact: format!("{:.1}", percent_ratio(denom - diffs, denom))
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     allele
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      non_negative_integer
doc:      TBD
brief:    donor allele for V region id
page:     enclone help cvars
avail:    public
notes:
code:     let mut allele = 0;
          if ex.share[mid].v_ref_id_donor_alt_id.is_some() {
              allele = ex.share[mid].v_ref_id_donor_alt_id.unwrap() + 1;
          }
          exact: format!("{}", allele)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     allele_d
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    donor allele evidence
page:     enclone help cvars
avail:    public
notes:
code:     let mut refs = Vec::<Vec<u8>>::new();
          let alt_refs = &allele_data.alt_refs;
          refs.push(refdata.refs[ex.share[mid].v_ref_id].to_ascii_vec());
          for i in 0..alt_refs.len() {
              // The following does not work correctly if an exact subclonotype contains cells
              // from more than one donor.  But that is extremely rare.
              if ex.clones[0][0].donor_index.is_some() {
                  if alt_refs[i].0 == ex.clones[0][0].donor_index.unwrap()
                      && alt_refs[i].1 == ex.share[mid].v_ref_id {
                      refs.push(alt_refs[i].2.to_ascii_vec());
                  }
              }
          }
          let mut m = refs[0].len();
          for i in 1..refs.len() {
              m = min(m, refs[i].len());
          }
          let mut ps = Vec::<usize>::new();
          let mut variant = Vec::<Vec<u8>>::new();
          for p in 0..m {
              let mut bases = Vec::<u8>::new();
              for i in 0..refs.len() {
                  bases.push(refs[i][p]);
              }
              let mut bases_sorted = bases.clone();
              unique_sort(&mut bases_sorted);
              if bases_sorted.len() > 1 {
                  ps.push(p);
                  variant.push(bases);
              }
          }
          let mut xs = Vec::<String>::new();
          for i in 0..refs.len() {
              let mut x = String::new();
              for j in 0..ps.len() {
                  x.push(variant[j][i] as char);
              }
              xs.push(x);
          }
          let mut me = String::new();
          for j in 0..ps.len() {
              let base = ex.share[mid].seq_del_amino[ps[j]];
              me.push(base as char);
          }
          let mut details = String::new();
          if ps.len() > 0 {
              details = format!("{me} : {}", xs.iter().format(","));
          }
          exact: details
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     barcode
inputs:   ?
limits:   only implemented for parseable output, and as an automatic field for clonotype tables in 
          PER_CELL mode
class:    lvar
level:    cell
val:      string
doc:      TBD
brief:    barcode of the cell
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     barcodes
inputs:   ?
limits:   only implemented for parseable output
class:    lvar
level:    exact
val:      string
doc:      TBD
brief:    barcodes for the exact subclonotype
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdiff
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    differences of const region with universal reference
page:     enclone help cvars
avail:    public
notes:
code:     let cstart = ex.share[mid].j_stop;
          let clen = ex.share[mid].full_seq.len() - cstart;
          let cid = ex.share[mid].c_ref_id;
          let mut cdiff = String::new();
          let mut ndiffs = 0;
          if cid.is_some() {
              let r = &refdata.refs[cid.unwrap()];
              let mut extra = 0;
              if clen > r.len() {
                  extra = clen - r.len();
              }
              for i in 0..min(clen, r.len()) {
                  let tb = ex.share[mid].full_seq[cstart + i];
                  let rb = r.to_ascii_vec()[i];
                  if tb != rb {
                      ndiffs += 1;
                      if ndiffs <= 5 {
                          cdiff += &format!("{}{}", i, tb as char);
                      }
                  }
              }
              if ndiffs > 5 {
                  cdiff += "...";
              }
              if extra > 0 {
                  cdiff += &format!("+{}", extra);
              }
          } else if clen > 0 {
              cdiff = format!("+{}", clen);
          }
          exact: cdiff
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr3_aa_conp
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    CDR3 amino acid consensus, symbols at variants
page:     enclone help cvars
avail:    public
notes:
code:     exact: cdr3_aa_con("p", col, exacts, exact_clonotypes, rsi)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr3_aa_conx
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    CDR3 amino acid clonotype consensus, Xs at variants
page:     enclone help cvars
avail:    public
notes:
code:     exact: cdr3_aa_con("x", col, exacts, exact_clonotypes, rsi)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr3_start
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      positive_integer
doc:      TBD
brief:    nucleotide start of CDR3 sequence on full sequence
page:     enclone help parseable
avail:    public
notes:    Check if type is really positive integer.
code:     exact: ex.share[mid].cdr3_start.to_string()
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr{1..2}_aa_ref
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    CDR* amino acid sequence for universal reference
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          if arg1 == 1 {
              if x.cdr1_start.is_some()
                  && x.fr2_start.is_some()
                  && x.cdr1_start.unwrap() <= x.fr2_start.unwrap()
              {
                  let dna = refdata.refs[x.v_ref_id].to_ascii_vec()
                      [x.cdr1_start.unwrap()..x.fr2_start.unwrap()]
                      .to_vec();
                  y = stringme(&aa_seq(&dna, 0));
              }
          } else if x.cdr2_start.is_some()
                  && x.fr3_start.is_some()
                  && x.cdr2_start.unwrap() <= x.fr3_start.unwrap()
          {
              let dna = refdata.refs[x.v_ref_id].to_ascii_vec()
                  [x.cdr2_start.unwrap()..x.fr3_start.unwrap()]
                  .to_vec();
              y = stringme(&aa_seq(&dna, 0));
          }
          exact: y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr{1..2}_dna_ref
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    CDR* nucleotide sequence for universal reference
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          if arg1 == 1 {
              if x.cdr1_start.is_some()
                  && x.fr2_start.is_some()
                  && x.cdr1_start.unwrap() <= x.fr2_start.unwrap()
              {
                  let dna = refdata.refs[x.v_ref_id].to_ascii_vec()
                      [x.cdr1_start.unwrap()..x.fr2_start.unwrap()]
                      .to_vec();
                  y = stringme(&dna);
              }
          } else if x.cdr2_start.is_some()
                  && x.fr3_start.is_some()
                  && x.cdr2_start.unwrap() <= x.fr3_start.unwrap()
          {
              let dna = refdata.refs[x.v_ref_id].to_ascii_vec()
                  [x.cdr2_start.unwrap()..x.fr3_start.unwrap()]
                  .to_vec();
              y = stringme(&dna);
          }
          exact: y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr{1..3}_aa
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    CDR* amino acid sequence
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          let c;
          if arg1 == 1 {
              c = get_cdr1(x, 0, 0);
              if c.is_some() {
                  y = stringme(&aa_seq(c.unwrap().as_bytes(), 0));
              }
          } else if arg1 == 2 {
              c = get_cdr2(x, 0, 0);
              if c.is_some() {
                  y = stringme(&aa_seq(c.unwrap().as_bytes(), 0));
              }
          } else {
              y = x.cdr3_aa.clone();
          }
          exact: y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr{1..3}_aa_north
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    North version of CDR* amino acid sequence
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          let c;
          if arg1 == 1 {
              let (mut left, mut right) = (0, 0);
              if x.left {
                  left = 3;
                  right = 3;
              }
              c = get_cdr1(x, left, right);
              if c.is_some() {
                  y = stringme(&aa_seq(c.unwrap().as_bytes(), 0));
              }
          } else if arg1 == 2 {
              let (left, right);
              if ex.share[mid].left {
                  left = 2;
                  right = 3;
              } else {
                  left = 1;
                  right = 0;
              }
              c = get_cdr2(x, left, right);
              if c.is_some() {
                  y = stringme(&aa_seq(c.unwrap().as_bytes(), 0));
              }
          } else {
              c = get_cdr3(x, -1, -1);
              if c.is_some() {
                  y = stringme(&aa_seq(c.unwrap().as_bytes(), 0));
              }
          }
          exact: y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr{1..3}_aa_{..}_{..}_ext
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    CDR* region with specified extension length
page:     enclone help cvars
avail:    public
notes:
code:     let (left, right) = (arg2 * 3, arg3 * 3);
          let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          let mut dna = Vec::<u8>::new();
          if arg1 == 1 {
              if x.cdr1_start.is_some()
                  && x.fr2_start.is_some()
                  && x.cdr1_start.unwrap() <= x.fr2_start.unwrap()
                  && x.cdr1_start.unwrap() as i64 - left >= 0
                  && x.cdr1_start.unwrap() as i64 - left < x.seq_del_amino.len() as i64
                  && x.fr2_start.unwrap() as i64 + right > 0
                  && x.fr2_start.unwrap() as i64 + right <= x.seq_del_amino.len() as i64
              {
                  for p in x.cdr1_start.unwrap() as i64 - left..
                      x.fr2_start.unwrap() as i64 + right {
                      let p = p as usize;
                      for j in 0..x.ins.len() {
                          if x.ins[j].0 == p {
                              let mut z = x.ins[j].1.clone();
                              dna.append(&mut z);
                          }
                      }
                      if x.seq_del_amino[p] != b'-' {
                          dna.push(x.seq_del_amino[p]);
                      }
                  }
                  test_internal_error_seq(&x.seq, &dna, &x.cdr3_aa)?;
                  y = stringme(&aa_seq(&dna, 0));
              }
          } else if arg1 == 2 {
              if x.cdr2_start.is_some()
                  && x.fr3_start.is_some()
                  && x.cdr2_start.unwrap() <= x.fr3_start.unwrap()
                  && x.cdr2_start.unwrap() as i64 - left >= 0
                  && x.cdr2_start.unwrap() as i64 - left < x.seq_del_amino.len() as i64
                  && x.fr3_start.unwrap() as i64 + right > 0
                  && x.fr3_start.unwrap() as i64 + right <= x.seq_del_amino.len() as i64
              {
                  for p in x.cdr2_start.unwrap() as i64 - left..
                      x.fr3_start.unwrap() as i64 + right {
                      let p = p as usize;
                      for j in 0..x.ins.len() {
                          if x.ins[j].0 == p {
                              let mut z = x.ins[j].1.clone();
                              dna.append(&mut z);
                          }
                      }
                      if x.seq_del_amino[p] != b'-' {
                          dna.push(x.seq_del_amino[p]);
                      }
                  }
                  test_internal_error_seq(&x.seq, &dna, &x.cdr3_aa)?;
                  y = stringme(&aa_seq(&dna, 0));
              }
          } else if x.cdr3_start as i64 - left >= 0
              && x.cdr3_start as i64 - left < x.seq_del_amino.len() as i64
              && x.cdr3_start as i64 + 3 * x.cdr3_aa.len() as i64 + right > 0
              && x.cdr3_start as i64 + 3 * x.cdr3_aa.len() as i64 + right
                  <= x.seq_del_amino.len() as i64
          {
              for p in
                  x.cdr3_start as i64 - left..
                      x.cdr3_start as i64 + 3 * x.cdr3_aa.len() as i64 + right
              {
                  let p = p as usize;
                  for j in 0..x.ins.len() {
                      if x.ins[j].0 == p {
                          let mut z = x.ins[j].1.clone();
                          dna.append(&mut z);
                      }
                  }
                  if x.seq_del_amino[p] != b'-' {
                      dna.push(x.seq_del_amino[p]);
                  }
              }
              test_internal_error_seq(&x.seq, &dna, &x.cdr3_aa)?;
              y = stringme(&aa_seq(&dna, 0));
          }
          exact: y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr{1..3}_dna
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    CDR* nucleotide sequence
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          let c;
          if arg1 == 1 {
              c = get_cdr1(x, 0, 0);
          } else if arg1 == 2 {
              c = get_cdr2(x, 0, 0);
          } else {
              c = Some(x.cdr3_dna.clone());
          }
          if c.is_some() {
              y = c.unwrap();
          }
          exact: y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr{1..3}_len
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      positive_integer
doc:      TBD
brief:    length of CDR* amino acid sequence 
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          let c;
          if arg1 == 1 {
              c = get_cdr1(x, 0, 0);
          } else if arg1 == 2 {
              c = get_cdr2(x, 0, 0);
          } else {
              c = Some(x.cdr3_dna.clone());
          }
          if c.is_some() {
              y = format!("{}", c.unwrap().len() / 3);
          }
          exact: y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cigar
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    CIGAR string defining edit of the V..J contig sequence
page:     enclone help cvars
avail:    public
notes:
code:     let vref = refdata.refs[rsi.vids[col]].to_ascii_vec();
          let mut dref = Vec::<u8>::new();
          if rsi.dids[col].is_some() {
              dref = refdata.refs[rsi.dids[col].unwrap()].to_ascii_vec();
          }
          let d2ref = Vec::<u8>::new();
          let jref = refdata.refs[rsi.jids[col]].to_ascii_vec();
          let td = &ex.share[mid];
          let tig = &td.seq;
          let ops = align_to_vdj_ref(
              tig,
              &vref,
              &dref,
              &d2ref,
              &jref,
              "", // drefname
              ex.share[mid].left,
              ctl,
          )
          .0;
          exact: cigar(&ops, 0, tig.len(), tig.len())
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     clen
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    length of observed constant region
page:     enclone help cvars
avail:    public
notes:
code:     exact: format!("{}", ex.share[mid].full_seq.len() - ex.share[mid].j_stop)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     clonotype_id
inputs:   ?
limits:   only implemented for parseable output
class:    lvar
level:    clono
val:      positive_integer
doc:      TBD
brief:    identifier of clonotype within clonotype group 
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     clonotype_ncells
inputs:   lvar_vdj
limits:
class:    lvar
level:    clono
val:      positive_integer
doc:      TBD
brief:    number of cells in the clonotype
page:     enclone help parseable
avail:    public
notes:
code:     let mut n = 0;
          for u in exacts.iter() {
              n += exact_clonotypes[*u].ncells();
          }
          exact: format!("{}", n)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     clust
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell-exect
val:      positive_integer
doc:      TBD
brief:    cluster id
page:     UNDOCUMENTED
avail:    private
notes:
code:     let mut clust = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              let mut cid = 0;
              let bc = &ex.clones[j][0].barcode;
              let li = ex.clones[j][0].dataset_index;
              if gex_info.cluster[li].contains_key(&bc.clone()) {
                  cid = gex_info.cluster[li][&bc.clone()];
              }
              clust.push(cid);
          }
          let mut clustf = Vec::<String>::new();
          for x in clust.iter() {
              clustf.push(format!("{}", x));
          }
          clust.sort_unstable();
          cell: clustf
          exact: abbrev_list(&clust)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     comp
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    CDR3 complexity number
page:     enclone help cvars
avail:    public
notes:
code:     let (comp, _edit) = comp_edit(ex, mid, col, refdata, dref, rsi);
          exact: format!("{}", comp)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     const
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    constant region name
page:     enclone help cvars
avail:    public
notes:
code:     let mut constx = Vec::<String>::new();
          let cid = ex.share[mid].c_ref_id;
          if cid.is_some() {
              constx.push(refdata.name[cid.unwrap()].clone());
          } else {
              constx.push("?".to_string());
          }
          unique_sort(&mut constx);
          // This is overcomplicated because there is now at most one
          // const entry per exact subclonotype.
          exact: format!("{}", constx.iter().format(","))
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     const_id
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      positive_integer_or_null
doc:      TBD
brief:    numerical identifier of constant region (or null)
page:     enclone help parseable
avail:    public
notes:
code:     let mut const_id = String::new();
          if ex.share[mid].c_ref_id.is_some() {
              const_id = format!("{}", refdata.id[ex.share[mid].c_ref_id.unwrap()]);
          }
          exact: const_id
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     count_REGA
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell-exact
val:      nonnegative_integer
doc:      TBD
brief:    count amino acid motifs
page:     enclone help lvars
avail:    public
notes:
code:     let mut n = 0;
          for j in 0..ex.share.len() {
              let aa = aa_seq(&ex.share[j].seq, 0); // seems inefficient
              n += reg.find_iter(strme(&aa)).count();
          }
          cell: vec![format!("{}", n); ex.ncells()]
          exact: format!("{}", n)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     count_cdr_REGA
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell-exact
val:      nonnegative_integer
doc:      TBD
brief:    count amino acid motifs using only cdr
page:     enclone help lvars
avail:    public
notes:
code:     let mut n = 0;
          for j in 0..ex.share.len() {
              if ex.share[j].cdr1_start.is_some() && ex.share[j].fr2_start.is_some() {
                  let cdr1 = ex.share[j].cdr1_start.unwrap();
                  let fwr2 = ex.share[j].fr2_start.unwrap();
                  if cdr1 < fwr2 {
                      let aa = aa_seq(&ex.share[j].seq[cdr1..fwr2], 0);
                      n += reg.find_iter(strme(&aa)).count();
                  }
              }
              if ex.share[j].cdr2_start.is_some() && ex.share[j].fr3_start.is_some() {
                  let cdr2 = ex.share[j].cdr2_start.unwrap();
                  let fwr3 = ex.share[j].fr3_start.unwrap();
                  if cdr2 < fwr3 {
                      let aa = aa_seq(&ex.share[j].seq[cdr2..fwr3], 0);
                      n += reg.find_iter(strme(&aa)).count();
                  }
              }
              let cdr3 = ex.share[j].cdr3_start;
              let fwr4 = cdr3 + 3 * ex.share[j].cdr3_aa.len();
              let aa = aa_seq(&ex.share[j].seq[cdr3..fwr4], 0);
              n += reg.find_iter(strme(&aa)).count();
          }
          cell: vec![format!("{}", n); ex.ncells()]
          exact: format!("{}", n)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     count_cdr{1..3}_REGA
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell-exact
val:      nonnegative_integer
doc:      TBD
brief:    count amino acid motifs using only the given CDR
page:     enclone help lvars
avail:    public
notes:
code:     let mut n = 0;
          if arg1 == 1 {
              for j in 0..ex.share.len() {
                  if ex.share[j].cdr1_start.is_some() && ex.share[j].fr2_start.is_some() {
                      let cdr1 = ex.share[j].cdr1_start.unwrap();
                      let fwr2 = ex.share[j].fr2_start.unwrap();
                      if cdr1 < fwr2 {
                          let aa = aa_seq(&ex.share[j].seq[cdr1..fwr2], 0);
                          n += reg.find_iter(strme(&aa)).count();
                      }
                  }
              }
          } else if arg1 == 2 {
              for j in 0..ex.share.len() {
                  if ex.share[j].cdr2_start.is_some() && ex.share[j].fr3_start.is_some() {
                      let cdr2 = ex.share[j].cdr2_start.unwrap();
                      let fwr3 = ex.share[j].fr3_start.unwrap();
                      if cdr2 < fwr3 {
                          let aa = aa_seq(&ex.share[j].seq[cdr2..fwr3], 0);
                          n += reg.find_iter(strme(&aa)).count();
                      }
                  }
              }
          } else {
              for j in 0..ex.share.len() {
                  let cdr3 = ex.share[j].cdr3_start;
                  let fwr4 = cdr3 + 3 * ex.share[j].cdr3_aa.len();
                  let aa = aa_seq(&ex.share[j].seq[cdr3..fwr4], 0);
                  n += reg.find_iter(strme(&aa)).count();
              }
          }
          cell: vec![format!("{}", n); ex.ncells()]
          exact: format!("{}", n)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     count_fwr_REGA
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell-exact
val:      nonnegative_integer
doc:      TBD
brief:    count amino acid motifs using only FWR
page:     enclone help lvars
avail:    public
notes:
code:     let mut n = 0;
          for j in 0..ex.share.len() {
              if ex.share[j].cdr1_start.is_some() {
                  let fwr1 = ex.share[j].fr1_start;
                  let cdr1 = ex.share[j].cdr1_start.unwrap();
                  if fwr1 < cdr1 {
                      let aa = aa_seq(&ex.share[j].seq[fwr1..cdr1], 0);
                      n += reg.find_iter(strme(&aa)).count();
                  }
              }
              if ex.share[j].fr2_start.is_some() && ex.share[j].cdr2_start.is_some() {
                  let fwr2 = ex.share[j].fr2_start.unwrap();
                  let cdr2 = ex.share[j].cdr2_start.unwrap();
                  if fwr2 < cdr2 {
                      let aa = aa_seq(&ex.share[j].seq[fwr2..cdr2], 0);
                      n += reg.find_iter(strme(&aa)).count();
                  }
              }
              if ex.share[j].fr3_start.is_some() {
                  let fwr3 = ex.share[j].fr3_start.unwrap();
                  let cdr3 = ex.share[j].cdr3_start;
                  if fwr3 < cdr3 {
                      let aa = aa_seq(&ex.share[j].seq[fwr3..cdr3], 0);
                      n += reg.find_iter(strme(&aa)).count();
                  }
              }
              let fwr4 = ex.share[j].cdr3_start + 3 * ex.share[j].cdr3_aa.len();
              let aa = aa_seq(&ex.share[j].seq[fwr4..], 0);
              n += reg.find_iter(strme(&aa)).count();
          }
          cell: vec![format!("{}", n); ex.ncells()]
          exact: format!("{}", n)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     count_fwr{1..4}_REGA
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell-exact
val:      nonnegative_integer
doc:      TBD
brief:    count amino acid motifs using only the given FWR
page:     enclone help lvars
avail:    public
notes:
code:     let mut n = 0;
          if arg1 == 1 {
              for j in 0..ex.share.len() {
                  if ex.share[j].cdr1_start.is_some() {
                      let fwr1 = ex.share[j].fr1_start;
                      let cdr1 = ex.share[j].cdr1_start.unwrap();
                      if fwr1 < cdr1 {
                          let aa = aa_seq(&ex.share[j].seq[fwr1..cdr1], 0);
                          n += reg.find_iter(strme(&aa)).count();
                      }
                  }
              }
          } else if arg1 == 2 {
              for j in 0..ex.share.len() {
                  if ex.share[j].fr2_start.is_some() && ex.share[j].cdr2_start.is_some() {
                      let fwr2 = ex.share[j].fr2_start.unwrap();
                      let cdr2 = ex.share[j].cdr2_start.unwrap();
                      if fwr2 < cdr2 {
                          let aa = aa_seq(&ex.share[j].seq[fwr2..cdr2], 0);
                          n += reg.find_iter(strme(&aa)).count();
                      }
                  }
              }
          } else if arg1 == 3 {
              for j in 0..ex.share.len() {
                  if ex.share[j].fr3_start.is_some() {
                      let fwr3 = ex.share[j].fr3_start.unwrap();
                      let cdr3 = ex.share[j].cdr3_start;
                      if fwr3 < cdr3 {
                          let aa = aa_seq(&ex.share[j].seq[fwr3..cdr3], 0);
                          n += reg.find_iter(strme(&aa)).count();
                      }
                  }
              }
          } else {
              for j in 0..ex.share.len() {
                  let fwr4 = ex.share[j].cdr3_start + 3 * ex.share[j].cdr3_aa.len();
                  let aa = aa_seq(&ex.share[j].seq[fwr4..], 0);
                  n += reg.find_iter(strme(&aa)).count();
              }
          }
          cell: vec![format!("{}", n); ex.ncells()]
          exact: format!("{}", n)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cred
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell-exact
val:      float
doc:      TBD
brief:    median credibility assessed using GEX data
page:     enclone help lvars
avail:    public
notes:
code:     let mut credsx = Vec::<f64>::new();
          for l in 0..ex.clones.len() {
              let bc = &ex.clones[l][0].barcode;
              let li = ex.clones[l][0].dataset_index;
              if gex_info.pca[li].contains_key(&bc.clone()) {
                  let mut creds = 0;
                  let mut z = Vec::<(f64, String)>::new();
                  let x = &gex_info.pca[li][&bc.clone()];
                  for y in gex_info.pca[li].iter() {
                      let mut dist2 = 0.0;
                      for m in 0..x.len() {
                          dist2 += (y.1[m] - x[m]) * (y.1[m] - x[m]);
                      }
                      z.push((dist2, y.0.clone()));
                  }
                  z.sort_by(|a, b| a.partial_cmp(b).unwrap());
                  let top = n_vdj_gex[li];
                  for i in 0..top {
                      if bin_member(&vdj_cells[li], &z[i].1) {
                          creds += 1;
                      }
                  }
                  let pc = 100.0 * creds as f64 / top as f64;
                  credsx.push(pc);
              } else {
                  credsx.push(0.0);
              }
          }
          let credsx_unsorted = credsx.clone();
          credsx.sort_by(|a, b| a.partial_cmp(b).unwrap());
          let mut r = Vec::<String>::new();
          for j in 0..credsx_unsorted.len() {
              r.push(format!("{:.1}", credsx_unsorted[j]));
          }
          cell: r
          exact: format!("{:.1}", median_f64(&credsx))
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d1_name
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    optimal D segment name
page:     enclone help cvars
avail:    public
notes:
code:     let mut opt_name = String::new();
          if ex.share[mid].left {
              let mut scores = Vec::<f64>::new();
              let mut ds = Vec::<Vec<usize>>::new();
              opt_d(ex, rsi.mat[col][u].unwrap(), refdata, dref, &mut scores, &mut ds, ctl, rsi.vpids[col]);
              let mut opt = Vec::new();
              if !ds.is_empty() {
                  opt = ds[0].clone();
              }
              if opt.is_empty() {
                  opt_name = "none".to_string();
              } else {
                  for i in 0..opt.len() {
                      if i > 0 {
                          opt_name += ":";
                      }
                      opt_name += &refdata.name[opt[i]];
                  }
              }
          }
          exact: opt_name
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d1_score
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      float
doc:      TBD
brief:    score of optimal D segment
page:     enclone help cvars
avail:    public
notes:
code:     let mut score = String::new();
          if ex.share[mid].left {
              let mut scores = Vec::<f64>::new();
              let mut ds = Vec::<Vec<usize>>::new();
              opt_d(ex, rsi.mat[col][u].unwrap(), refdata, dref, &mut scores, &mut ds, ctl, rsi.vpids[col]);
              let mut delta = 0.0;
              if scores.len() > 1 {
                  delta = scores[0] - scores[1];
              }
              score = format!("{:.1}", delta)
          }
          exact: score
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d2_name
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    second best D segment name
page:     enclone help cvars
avail:    public
notes:
code:     let mut opt2_name = String::new();
          if ex.share[mid].left {
              let mut scores = Vec::<f64>::new();
              let mut ds = Vec::<Vec<usize>>::new();
              opt_d(ex, rsi.mat[col][u].unwrap(), refdata, dref, &mut scores, &mut ds, ctl, rsi.vpids[col]);
              let mut opt2 = Vec::new();
              if ds.len() > 1 {
                  opt2 = ds[1].clone();
              }
              if opt2.is_empty() {
                  opt2_name = "none".to_string();
              } else {
                  for i in 0..opt2.len() {
                      if i > 0 {
                          opt2_name += ":";
                      }
                      opt2_name += &refdata.name[opt2[i]];
                  }
              }
          }
          exact: opt2_name
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d2_score
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      float
doc:      TBD
brief:    score of second best D segment
page:     enclone help cvars
avail:    public
notes:
code:     let mut scorex = String::new();
          if ex.share[mid].left {
              let mut scores = Vec::<f64>::new();
              let mut ds = Vec::<Vec<usize>>::new();
              opt_d(ex, rsi.mat[col][u].unwrap(), refdata, dref, &mut scores, &mut ds, ctl, rsi.vpids[col]);
              let mut score = 0.0;
              if scores.len() > 1 {
                  score = scores[1];
              }
              scorex = format!("{:.1}", score)
          }
          exact: scorex
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d_delta
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      float
doc:      TBD
brief:    score delta between top two D gene assignments
page:     enclone help cvars
avail:    public
notes:
code:     let mut del = String::new();
          if ex.share[mid].left {
              let mut scores = Vec::<f64>::new();
              let mut ds = Vec::<Vec<usize>>::new();
              opt_d(ex, rsi.mat[col][u].unwrap(), refdata, dref, &mut scores, &mut ds, ctl, rsi.vpids[col]);
              let mut delta = 0.0;
              if scores.len() > 1 {
                  delta = scores[0] - scores[1];
              }
              del = format!("{:.1}", delta)
          }
          exact: del
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d_donor
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    distance from donor reference
page:     enclone help cvars
avail:    public
notes:
code:     let vid = ex.share[mid].v_ref_id;
          let mut vref = refdata.refs[vid].to_ascii_vec();
          if rsi.vpids[col].is_some() {
              vref = dref[rsi.vpids[col].unwrap()].nt_sequence.clone();
          }
          let jid = ex.share[mid].j_ref_id;
          let jref = &refdata.refs[jid].to_ascii_vec();
          let tig = &ex.share[mid].seq_del;
          let n = tig.len();
          let mut diffs = 0;
          for p in 0..n {
              if tig[p] == b'-' {
                  continue;
              }
              if p < vref.len() - ctl.heur.ref_v_trim && tig[p] != vref[p] {
                  diffs += 1;
              } else if p >= n - (jref.len() - ctl.heur.ref_j_trim)
                  && tig[p] != jref[jref.len() - (n - p)]
              {
                  diffs += 1;
              }
          }
          exact: format!("{}", diffs)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d_frame
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    reading frame of D segment (0, 1, 2 or null)
page:     enclone help parseable
avail:    public
notes:
code:     let mut d_frame = String::new();
          if ex.share[mid].d_start.is_some() {
              d_frame = format!(
                  "{}",
                  (ex.share[mid].d_start.unwrap() - ex.share[mid].v_start) % 3
              );
          }
          exact: d_frame
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d_id
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      positive_integer
doc:      TBD
brief:    D region id
page:     enclone help parseable
avail:    public
notes:
code:     let did = if rsi.dids[col].is_some() {
              format!("{}", refdata.id[rsi.dids[col].unwrap()])
          } else {
              String::new()
          };
          exact: did
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d_inconsistent_%
inputs:   ?
limits:
class:    lvar
level:    global
val:      float[0,100].precision(1)
doc:      TBD
brief:    inconsistency percent for D gene assignment
page:     d_genes.html
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d_inconsistent_n
inputs:   ?
limits:
class:    lvar
level:    global
val:      positive_integer
doc:      TBD
brief:    sample size for computation of <code>d_inconsistent_%</code> 
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d_name
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    D region name
page:     enclone help parseable
avail:    public
notes:
code:     let dname = if rsi.dids[col].is_some() {
              refdata.name[rsi.dids[col].unwrap()].clone()
          } else {
              String::new()
          };
          exact: dname
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d_start
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    start of D on full nucleotide sequence (or null)
page:     enclone help parseable
avail:    public
notes:    Starts at 0 or 1?
code:     let mut d_start = String::new();
          if ex.share[mid].d_start.is_some() {
              d_start = format!("{}", ex.share[mid].d_start.unwrap());
          }
          exact: d_start
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d_univ
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    distance from universal reference
page:     enclone help cvars
avail:    public
notes:
code:     let vid = ex.share[mid].v_ref_id;
          let vref = &refdata.refs[vid].to_ascii_vec();
          let jid = ex.share[mid].j_ref_id;
          let jref = &refdata.refs[jid].to_ascii_vec();
          let tig = &ex.share[mid].seq_del;
          let n = tig.len();
          let mut diffs = 0;
          for p in 0..n {
              if tig[p] == b'-' {
                  continue;
              }
              if p < vref.len() - ctl.heur.ref_v_trim && tig[p] != vref[p] {
                  diffs += 1;
              } else if p >= n - (jref.len() - ctl.heur.ref_j_trim)
                  && tig[p] != jref[jref.len() - (n - p)]
              {
                  diffs += 1;
              }
          }
          exact: format!("{}", diffs)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d_Δ
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      float
doc:      TBD
brief:    score delta between top two D gene assignments
page:     enclone help cvars
avail:    public
notes:
code:     let mut del = String::new();
          if ex.share[mid].left {
              let mut scores = Vec::<f64>::new();
              let mut ds = Vec::<Vec<usize>>::new();
              opt_d(ex, rsi.mat[col][u].unwrap(), refdata, dref, &mut scores, &mut ds, ctl, rsi.vpids[col]);
              let mut delta = 0.0;
              if scores.len() > 1 {
                  delta = scores[0] - scores[1];
              }
              del = format!("{:.1}", delta)
          }
          exact: del
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     datasets
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell-exact
val:      string
doc:      TBD
brief:    dataset names
page:     enclone help lvars
avail:    public
notes:
code:     let mut datasets = Vec::<String>::new();
          for j in 0..ex.clones.len() {
              datasets.push(ctl.origin_info.dataset_id[ex.clones[j][0].dataset_index].clone());
          }
          let mut datasets_unique = datasets.clone();
          unique_sort(&mut datasets_unique);
          cell: datasets
          exact: format!("{}", datasets_unique.iter().format(","))
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     dna%
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      float[0,100].precision(1)
doc:      TBD
brief:    nucleotide identity with donor reference
page:     enclone help cvars
avail:    public
notes:
code:     let xm = &ex.share[mid];
          let mut diffs = 0;
          let mut denom = 0;
          let seq = &xm.seq_del_amino;
          let mut vref = refdata.refs[xm.v_ref_id].to_ascii_vec();
          if xm.v_ref_id_donor_alt_id.is_some() {
              vref = dref[xm.v_ref_id_donor.unwrap()].nt_sequence.clone();
          }
          let jref = refdata.refs[xm.j_ref_id].to_ascii_vec();
          let z = seq.len();
          for p in 0..z {
              let b = seq[p];
              if b == b'-' {
                  diffs += 1;
                  denom += 1;
                  continue;
              }
              if p < vref.len() - ctl.heur.ref_v_trim {
                  denom += 1;
                  if b != vref[p] {
                      diffs += 1;
                  }
              }
              if p >= z - (jref.len() - ctl.heur.ref_j_trim) {
                  denom += 1;
                  if b != jref[jref.len() - (z - p)] {
                      diffs += 1;
                  }
              }
          }
          exact: format!("{:.1}", percent_ratio(denom - diffs, denom))
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     donors
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell-exact
val:      string
doc:      TBD
brief:    donor names
page:     enclone help lvars
avail:    public
notes:
code:     let mut donors = Vec::<String>::new();
          for j in 0..ex.clones.len() {
              if ex.clones[j][0].donor_index.is_some() {
                  donors
                      .push(ctl.origin_info.donor_list[ex.clones[j][0].donor_index.unwrap()]
                          .clone());
              } else {
                  donors.push("?".to_string());
              }
          }
          let donors_unsorted = donors.clone();
          unique_sort(&mut donors);
          cell: donors_unsorted
          exact: format!("{}", donors.iter().format(","))
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     dref
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    nucleotide distance to donor reference
page:     enclone help lvars
avail:    public
notes:
code:
          let mut diffs = 0;
          for m in 0..cols {
              if mat[m][u].is_some() {
                  let r = mat[m][u].unwrap();
                  let seq = &ex.share[r].seq_del_amino;
                  let mut vref = refdata.refs[rsi.vids[m]].to_ascii_vec();
                  if rsi.vpids[m].is_some() {
                      vref = dref[rsi.vpids[m].unwrap()].nt_sequence.clone();
                  }
                  let jref = refdata.refs[rsi.jids[m]].to_ascii_vec();
                  let z = seq.len();
                  for p in 0..z {
                      let b = seq[p];
                      if p < vref.len() - ctl.heur.ref_v_trim && b != vref[p] {
                          diffs += 1;
                      }
                      if p >= z - (jref.len() - ctl.heur.ref_j_trim)
                          && b != jref[jref.len() - (z - p)]
                      {
                          diffs += 1;
                      }
                  }
              }
          }
          exact: format!("{}", diffs)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     dref_aa
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    amino acid distance to donor reference
page:     enclone help lvars
avail:    public
notes:
code:     let mut diffs = 0;
          for m in 0..cols {
              if mat[m][u].is_some() {
                  let r = mat[m][u].unwrap();
                  let aa_seq = &ex.share[r].aa_mod_indel;
                  let mut vref = refdata.refs[rsi.vids[m]].to_ascii_vec();
                  if rsi.vpids[m].is_some() {
                      vref = dref[rsi.vpids[m].unwrap()].nt_sequence.clone();
                  }
                  let jref = refdata.refs[rsi.jids[m]].to_ascii_vec();
                  let z = 3 * aa_seq.len() + 1;
                  for p in 0..aa_seq.len() {
                      if aa_seq[p] == b'-' {
                          diffs += 1;
                          continue;
                      }
                      if 3 * p + 3 <= vref.len() - ctl.heur.ref_v_trim
                          && aa_seq[p] != codon_to_aa(&vref[3 * p..3 * p + 3])
                      {
                          diffs += 1;
                      }
                      if 3 * p > z - (jref.len() - ctl.heur.ref_j_trim) + 3
                          && aa_seq[p]
                              != codon_to_aa(
                                  &jref[jref.len() - (z - 3 * p)..jref.len() - (z - 3 * p) + 3],
                              )
                      {
                          diffs += 1;
                      }
                  }
              }
          }
          exact: format!("{}", diffs)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     dref_max
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    nucleotide distance to donor reference, max over chains
page:     enclone help lvars
avail:    public
notes:
code:
          let mut mx = 0;
          for m in 0..cols {
              let mut diffs = 0;
              if mat[m][u].is_some() {
                  let r = mat[m][u].unwrap();
                  let seq = &ex.share[r].seq_del_amino;
                  let mut vref = refdata.refs[rsi.vids[m]].to_ascii_vec();
                  if rsi.vpids[m].is_some() {
                      vref = dref[rsi.vpids[m].unwrap()].nt_sequence.clone();
                  }
                  let jref = refdata.refs[rsi.jids[m]].to_ascii_vec();
                  let z = seq.len();
                  for p in 0..z {
                      let b = seq[p];
                      if p < vref.len() - ctl.heur.ref_v_trim && b != vref[p] {
                          diffs += 1;
                      }
                      if p >= z - (jref.len() - ctl.heur.ref_j_trim)
                          && b != jref[jref.len() - (z - p)]
                      {
                          diffs += 1;
                      }
                  }
                  mx = std::cmp::max(mx, diffs);
              }
          }
          exact: format!("{}", mx)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     edit
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    edit versus reference CDR3
page:     enclone help cvars
avail:    public
notes:
code:     let (_comp, edit) = comp_edit(ex, mid, col, refdata, dref, rsi);
          exact: edit
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     entropy
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell-exact
val:      float
doc:      TBD
brief:    entropy of gene expression values
page:     UNDOCUMENTED
avail:    private
notes:    
code:     let mut total_counts = Vec::<usize>::new();
          for l in 0..ex.clones.len() {
              let li = ex.clones[l][0].dataset_index;
              let bc = ex.clones[l][0].barcode.clone();
              if !gex_info.gex_barcodes.is_empty() {
                  let p = bin_position(&gex_info.gex_barcodes[li], &bc);
                  if p >= 0 {
                      let mut raw_count = 0;
                      if gex_info.gex_matrices[li].initialized() {
                          let row = gex_info.gex_matrices[li].row(p as usize);
                          for j in 0..row.len() {
                              let f = row[j].0;
                              let n = row[j].1;
                              if gex_info.is_gex[li][f] {
                                  raw_count += n;
                              }
                          }
                      } else {
                          let z1 = gex_info.h5_indptr[li][p as usize] as usize;
                          let z2 = gex_info.h5_indptr[li][p as usize + 1] as usize; // is p+1 OK??
                          let d: Vec<u32>;
                          let ind: Vec<u32>;
                          if ctl.gen_opt.h5_pre {
                              d = h5_data[li].1[z1..z2].to_vec();
                              ind = h5_data[li].2[z1..z2].to_vec();
                          } else {
                              d = d_readers[li]
                                  .as_ref()
                                  .unwrap()
                                  .read_slice(s![z1..z2])
                                  .unwrap()
                                  .to_vec();
                              ind = ind_readers[li]
                                  .as_ref()
                                  .unwrap()
                                  .read_slice(s![z1..z2])
                                  .unwrap()
                                  .to_vec();
                          }
                          for j in 0..d.len() {
                              if gex_info.is_gex[li][ind[j] as usize] {
                                  raw_count += d[j] as usize;
                              }
                          }
                      }
                      total_counts.push(raw_count);
                  }
              }
          }
          let mut entropies = Vec::<f64>::new();
          for l in 0..ex.clones.len() {
              let li = ex.clones[l][0].dataset_index;
              let bc = ex.clones[l][0].barcode.clone();
              if !gex_info.gex_barcodes.is_empty() {
                  let mut entropy = 0.0;
                  let p = bin_position(&gex_info.gex_barcodes[li], &bc);
                  if p >= 0 {
                      if gex_info.gex_matrices[li].initialized() {
                          let row = gex_info.gex_matrices[li].row(p as usize);
                          for j in 0..row.len() {
                              let f = row[j].0;
                              let n = row[j].1;
                              if gex_info.is_gex[li][f] {
                                  let q = n as f64 / total_counts[l] as f64;
                                  entropy -= q * q.log2();
                              }
                          }
                      } else {
                          let z1 = gex_info.h5_indptr[li][p as usize] as usize;
                          let z2 = gex_info.h5_indptr[li][p as usize + 1] as usize; // is p+1 OK??
                          let d: Vec<u32>;
                          let ind: Vec<u32>;
                          if ctl.gen_opt.h5_pre {
                              d = h5_data[li].1[z1..z2].to_vec();
                              ind = h5_data[li].2[z1..z2].to_vec();
                          } else {
                              d = d_readers[li]
                                  .as_ref()
                                  .unwrap()
                                  .read_slice(s![z1..z2])
                                  .unwrap()
                                  .to_vec();
                              ind = ind_readers[li]
                                  .as_ref()
                                  .unwrap()
                                  .read_slice(s![z1..z2])
                                  .unwrap()
                                  .to_vec();
                          }
                          for j in 0..d.len() {
                              if gex_info.is_gex[li][ind[j] as usize] {
                                  let n = d[j] as usize;
                                  let q = n as f64 / total_counts[l] as f64;
                                  entropy -= q * q.log2();
                              }
                          }
                      }
                  }
                  entropies.push(entropy);
              }
          }
          let entropies_unsorted = entropies.clone();
          entropies.sort_by(|a, b| a.partial_cmp(b).unwrap());
          let mut entropy = 0.0;
          if !entropies.is_empty() {
              entropy = median_f64(&entropies);
          }
          let mut e = Vec::<String>::new();
          for x in entropies_unsorted.iter() {
              e.push(format!("{:.2}", x));
          }
          cell: e
          exact: format!("{:.2}", entropy)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     exact_subclonotype_id
inputs:   ?
limits:
class:    lvar
level:    exact
val:      positive_integer
doc:      TBD
brief:    identifier of exact subclonotype
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     far
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    Hamming distance to farthest neighbor 
page:     enclone help lvars
avail:    public
notes:    
code:     let mut dist = -1_isize;
          for i2 in 0..varmat.len() {
              if i2 == u || fp[i2] != fp[u] {
                  continue;
              }
              let mut d = 0_isize;
              for c in fp[u].iter() {
                  for j in 0..varmat[u][*c].len() {
                      if varmat[u][*c][j] != varmat[i2][*c][j] {
                          d += 1;
                      }
                  }
              }
              dist = max(dist, d);
          }
          let d;
          if dist == -1_isize {
              d = "".to_string();
          } else {
              d = format!("{}", dist);
          }
          exact: d
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     fb{1..}
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      string
doc:      TBD
brief:    sequence of the nth most frequent feature barcode
page:     enclone help lvars
avail:    private
notes:    
code:     let ncols = gex_info.fb_top_matrices[0].ncols();
          let n = (arg1 - 1) as usize;
          let fb = if n < ncols {
              gex_info.fb_top_matrices[0].col_label(n)
          } else {
              String::new()
          };
          exact: (*fb).to_string()
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     fb{1..}_n
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell-exact
val:      nonnegative integer
doc:      TBD
brief:    number of UMIs for the nth most frequent feature barcode
page:     enclone help lvars
avail:    private
notes:    
code:     let ncols = gex_info.fb_top_matrices[0].ncols();
          let n = (arg1 - 1) as usize;
          let median;
          let mut counts;
          if n >= ncols {
              median = 0;
              counts = vec!["0".to_string(); ex.ncells()];
          } else {
              counts = Vec::<String>::new();
              let mut counts_sorted = Vec::<usize>::new();
              for l in 0..ex.clones.len() {
                  let bc = ex.clones[l][0].barcode.clone();
                  let p = bin_position(&gex_info.fb_top_barcodes[0], &bc);
                  if p < 0 {
                      counts.push("0".to_string());
                      counts_sorted.push(0);
                  } else {
                      let x = gex_info.fb_top_matrices[0].value(p as usize, n);
                      counts.push(format!("{}", x));
                      counts_sorted.push(x);
                  }
              }
              counts_sorted.sort_unstable();
              median = rounded_median(&counts_sorted);
          }
          cell: counts
          exact: format!("{}", median)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     filter
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell
val:      string
doc:      TBD
brief:    name of filter that would be applied (if filters off)
page:     enclone help lvars
avail:    public
notes:
code:     let mut fates = Vec::<String>::new();
          for j in 0..ex.clones.len() {
              let mut f = String::new();
              let bc = &ex.clones[j][0].barcode;
              let li = ex.clones[j][0].dataset_index;
              if fate[li].contains_key(&bc.clone()) {
                  f = fate[li][&bc.clone()].clone();
                  f = f.between(" ", " ").to_string();
              }
              fates.push(f);
          }
          cell: fates
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     fwr{1..4}_aa
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    FWR* amino acid sequence
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          let c;
          if arg1 == 1 {
              c = get_fwr1(x);
          } else if arg1 == 2 {
              c = get_fwr2(x);
          } else if arg1 == 3 {
              c = get_fwr3(x);
          } else {
              let x = &ex.share[mid];
              let start = rsi.cdr3_starts[col] + 3 * rsi.cdr3_lens[col];
              let stop = rsi.seq_del_lens[col];
              let dna = &x.seq_del_amino[start..stop];
              c = Some(stringme(dna));
          }
          if c.is_some() {
              y = stringme(&aa_seq(c.unwrap().as_bytes(), 0));
          }
          exact: y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     fwr{1..4}_aa_ref
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    FWR* amino acid seq for universal reference
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          if arg1 == 1 {
              if x.cdr1_start.is_some() && x.fr1_start <= x.cdr1_start.unwrap() {
                  let dna = refdata.refs[x.v_ref_id].to_ascii_vec()[x.fr1_start..x.cdr1_start
                      .unwrap()]
                      .to_vec();
                  y = stringme(&aa_seq(&dna, 0));
              }
          } else if arg1 == 2 {
              if x.fr2_start.unwrap() <= x.cdr2_start.unwrap() {
                  let dna = refdata.refs[x.v_ref_id].to_ascii_vec()
                      [x.fr2_start.unwrap()..x.cdr2_start.unwrap()]
                      .to_vec();
                  y = stringme(&aa_seq(&dna, 0));
              }
          } else if arg1 == 3 {
              if x.fr3_start.is_some() && x.fr3_start.unwrap() <= x.cdr3_start - x.ins_len() {
                  let dna = refdata.refs[x.v_ref_id].to_ascii_vec();
                  if x.cdr3_start <= dna.len() {
                      let dna = dna[x.fr3_start.unwrap()..x.cdr3_start - x.ins_len()].to_vec();
                      y = stringme(&aa_seq(&dna, 0));
                  }
              }
          } else {
              let heavy = refdata.rtype[x.j_ref_id] == 0;
              let aa_len;
              if heavy {
                  aa_len = 10;
              } else {
                  aa_len = 9;
              }
              let dna = refdata.refs[x.j_ref_id].to_ascii_vec();
              let dna = dna[dna.len() - 1 - 3 * aa_len..dna.len() - 1].to_vec();
              y = stringme(&aa_seq(&dna, 0));
          }
          exact: y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     fwr{1..4}_dna
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    FWR* nucleotide sequence
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          let c;
          if arg1 == 1 {
              c = get_fwr1(x);
          } else if arg1 == 2 {
              c = get_fwr2(x);
          } else if arg1 == 3 {
              c = get_fwr3(x);
          } else {
              let x = &ex.share[mid];
              let start = rsi.cdr3_starts[col] + 3 * rsi.cdr3_lens[col];
              let stop = rsi.seq_del_lens[col];
              let dna = &x.seq_del_amino[start..stop];
              c = Some(stringme(dna));
          }
          if c.is_some() {
              y = c.unwrap();
          }
          exact: y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     fwr{1..4}_dna_ref
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    FWR* nucleotide seq for universal reference
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          if arg1 == 1 {
              if x.cdr1_start.is_some() && x.fr1_start <= x.cdr1_start.unwrap() {
                  let dna = refdata.refs[x.v_ref_id].to_ascii_vec()[x.fr1_start..x.cdr1_start
                      .unwrap()]
                      .to_vec();
                  y = stringme(&dna);
              }
          } else if arg1 == 2 {
              if x.fr2_start.unwrap() <= x.cdr2_start.unwrap() {
                  let dna = refdata.refs[x.v_ref_id].to_ascii_vec()
                      [x.fr2_start.unwrap()..x.cdr2_start.unwrap()]
                      .to_vec();
                  y = stringme(&dna);
              }
          } else if arg1 == 3 {
              if x.fr3_start.is_some() && x.fr3_start.unwrap() <= x.cdr3_start - x.ins_len() {
                  let dna = refdata.refs[x.v_ref_id].to_ascii_vec();
                  if x.cdr3_start <= dna.len() {
                      let dna = dna[x.fr3_start.unwrap()..x.cdr3_start - x.ins_len()].to_vec();
                      y = stringme(&dna);
                  }
              }
          } else {
              let heavy = refdata.rtype[x.j_ref_id] == 0;
              let aa_len;
              if heavy {
                  aa_len = 10;
              } else {
                  aa_len = 9;
              }
              let dna = refdata.refs[x.j_ref_id].to_ascii_vec();
              let dna = dna[dna.len() - 1 - 3 * aa_len..dna.len() - 1].to_vec();
              y = stringme(&dna);
          }
          exact: y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     fwr{1..4}_len
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    length of FWR* nucleotide sequence
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          let c;
          if arg1 == 1 {
              c = get_fwr1(x);
          } else if arg1 == 2 {
              c = get_fwr2(x);
          } else if arg1 == 3 {
              c = get_fwr3(x);
          } else {
              let x = &ex.share[mid];
              let start = rsi.cdr3_starts[col] + 3 * rsi.cdr3_lens[col];
              let stop = rsi.seq_del_lens[col];
              let dna = &x.seq_del_amino[start..stop];
              c = Some(stringme(dna));
          }
          if c.is_some() {
              y = format!("{}", c.unwrap().len() / 3);
          }
          exact: y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     gex
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell-exact
val:      float
doc:      TBD
brief:    number of GEX UMIs (or median)
page:     enclone help lvars
avail:    public
notes:
code:     let mut f = Vec::<String>::new();
          for x in gex_fcounts_unsorted.iter() {
              f.push(format!("{}", *x));
          }   
          let mut counts = gex_counts_unsorted.clone();
          counts.sort_unstable();
          let gex_median = rounded_median(&counts);
          cell: f
          exact: format!("{}", gex_median)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     gex_max
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    maximum number of GEX UMIs across exact subclonotype
page:     enclone help lvars
avail:    public
notes:
code:     exact: format!("{}", gex_counts_unsorted.iter().max().unwrap())
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     gex_mean
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      float
doc:      TBD
brief:    mean of GEX UMIs across exact subclonotype (= <code>gex_μ</code>)
page:     enclone help lvars
avail:    public
notes:
code:     let gex_sum = gex_fcounts_unsorted.iter().sum::<f64>();
          let gex_mean = gex_sum / gex_fcounts_unsorted.len() as f64;
          exact: format!("{}", gex_mean.round() as usize)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     gex_min
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    minimum number of GEX UMIs across exact subclonotype 
page:     enclone help lvars
avail:    public
notes:
code:     exact: format!("{}", gex_counts_unsorted.iter().min().unwrap())
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     gex_sum
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    sum of GEX UMIs across exact subclonotype (= <code>gex_Σ</code>) 
page:     enclone help lvars
avail:    public
notes:
code:     let gex_sum = gex_fcounts_unsorted.iter().sum::<f64>();
          exact: format!("{}", gex_sum.round() as usize)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     gex_Σ
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    sum of GEX UMIs across exact subclonotype (= <code>gex_sum</code>)
page:     enclone help lvars
avail:    public
notes:
code:     let gex_sum = gex_fcounts_unsorted.iter().sum::<f64>();
          exact: format!("{}", gex_sum.round() as usize)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     gex_μ
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      float
doc:      TBD
brief:    mean of GEX UMIs across exact subclonotype (= <code>gex_mean</code>)
page:     enclone help lvars
avail:    public
notes:
code:     let gex_sum = gex_fcounts_unsorted.iter().sum::<f64>();
          let gex_mean = gex_sum / gex_fcounts_unsorted.len() as f64;
          exact: format!("{}", gex_mean.round() as usize)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     group_id
inputs:   ?
limits:   only implemented for parseable output
class:    lvar
level:    group
val:      positive_integer
doc:      TBD
brief:    identifier of clonotype group
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     group_ncells
inputs:   ?
limits:   only implemented for parseable output
class:    lvar
level:    group
val:      positive_integer
doc:      TBD
brief:    number of cells in clonotype group
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     g{0..}
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      positive_integer
doc:      TBD
brief:    exact subclonotype group, by Hamming distance
page:     enclone help lvars
avail:    public
notes:
code:     let d = arg1 as usize;
          let answer = if groups.contains_key(&d) { 
              format!("{}", groups[&d][u] + 1) 
          } else { 
              String::new()
          };
          exact: answer
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     hcomp
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    CDR3 complexity number, heavy chain only, canonical only, computed better
page:     enclone help lvars
avail:    public
notes:
code:     let mut hcomp = String::new();
          if ex.share.len() == 2 {
              for j in 0..ex.share.len() {
                  if ex.share[j].left {
                      hcomp = format!("{}", ex.share[j].jun.hcomp);
                  }
              }
          }
          exact: hcomp
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     inkt
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      string
doc:      TBD
brief:    evidence for iNKT cell 
page:     enclone help lvars
avail:    public
notes:
code:     let mut s = String::new();
          let alpha_g = ex.share[0].inkt_alpha_chain_gene_match;
          let alpha_j = ex.share[0].inkt_alpha_chain_junction_match;
          let beta_g = ex.share[0].inkt_beta_chain_gene_match;
          let beta_j = ex.share[0].inkt_beta_chain_junction_match;
          if alpha_g || alpha_j {
              s += "𝝰";
              if alpha_g {
                  s += "g";
              }
              if alpha_j {
                  s += "j";
              }
          }
          if beta_g || beta_j {
              s += "𝝱";
              if beta_g {
                  s += "g";
              }
              if beta_j {
                  s += "j";
              }
          }
          exact: s
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     ivalbcumis
inputs:   cvar_vdj
limits:
class:    cvar
level:    cell
val:      string
doc:      TBD
brief:    invalidated UMIs, preceded by barcode
page:     UNDOCUMENTED
avail:    private
notes:
code:     let mut vals = Vec::<String>::new();
          for k in 0..ex.ncells() {
              let mut n = String::new();
              if ex.clones[k][mid].invalidated_umis.is_some() {
                  let mut bc_umis = ex.clones[k][mid].invalidated_umis.clone().unwrap();
                  for i in 0..bc_umis.len() {
                      bc_umis[i] =
                          format!("{}{}", ex.clones[k][mid].barcode.before("-"), bc_umis[i]);
                  }
                  n = format!("{}", bc_umis.iter().format(","));
              }
              vals.push(n.to_string());
          }
          cell: vals
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     ivalumis
inputs:   cvar_vdj
limits:
class:    cvar
level:    cell
val:      string
doc:      TBD
brief:    invalidated UMIs
page:     UNDOCUMENTED
avail:    private
notes:
code:     let mut vals = Vec::<String>::new();
          for k in 0..ex.ncells() {
              let mut n = String::new();
              if ex.clones[k][mid].invalidated_umis.is_some() {
                  n = format!(
                      "{}",
                      ex.clones[k][mid]
                          .invalidated_umis
                          .as_ref()
                          .unwrap()
                          .iter()
                          .format(",")
                  );
              }
              vals.push(n.to_string());
          }
          cell: vals
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     j_id
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      positive_integer
doc:      TBD
brief:    J region id
page:     enclone help parseable
avail:    public
notes:
code:     exact: format!("{}", refdata.id[rsi.jids[col]])
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     j_name
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    J region name
page:     enclone help parseable
avail:    public
notes:
code:     exact: refdata.name[rsi.jids[col]].clone()
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     jun_ins
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    number of inserted bases in heavy chain junction, only computed in two-chain case
page:     enclone help lvars
avail:    public
notes:
code:     let mut jun_ins = String::new();
          if ex.share.len() == 2 {
              for j in 0..ex.share.len() {
                  if ex.share[j].left {
                      jun_ins = format!("{}", ex.share[j].jun.jun_ins);
                  }
              }
          }
          exact: jun_ins
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     mait
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      string
doc:      TBD
brief:    evidence for MAIT cell 
page:     enclone help lvars
avail:    public
notes:
code:     let mut s = String::new();
          let alpha_g = ex.share[0].mait_alpha_chain_gene_match;
          let alpha_j = ex.share[0].mait_alpha_chain_junction_match;
          let beta_g = ex.share[0].mait_beta_chain_gene_match;
          let beta_j = ex.share[0].mait_beta_chain_junction_match;
          if alpha_g || alpha_j {
              s += "𝝰";
              if alpha_g {
                  s += "g";
              }
              if alpha_j {
                  s += "j";
              }
          }
          if beta_g || beta_j {
              s += "𝝱";
              if beta_g {
                  s += "g";
              }
              if beta_j {
                  s += "j";
              }
          }
          exact: s
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     mark
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      nonnegative integer
doc:      TBD
brief:    is cell marked
page:     UNDOCUMENTED
avail:    private
notes:
code:     let mut n = 0;
          for j in 0..ex.clones.len() {
              if ex.clones[j][0].marked {
                  n += 1;
              }
          }
          exact: format!("{}", n)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     mem
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell-exact
val:      nonnegative integer
doc:      TBD
brief:    for human or mouse BCR, number of GEX UMIs that are characterized as membrane
page:     UNDOCUMENTED
avail:    private
notes:
code:     let mut n = 0;
          let mut y = Vec::<String>::new();
          if ctl.gen_opt.using_secmem {
              for l in 0..ex.clones.len() {
                  let li = ex.clones[l][0].dataset_index;
                  let bc = &ex.clones[l][0].barcode;
                  let mut count = 0;
                  if ctl.origin_info.secmem[li].contains_key(&bc.clone()) {
                      count = ctl.origin_info.secmem[li][&bc.clone()].1;
                      n += count;
                  }
                  y.push(format!("{}", count));
              }
          }
          cell: y
          exact: format!("{}", n)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     n
inputs:   lvar_vdj
limits:   <code>PER_CELL</code> values are not displayed because they are all <code>1</code>, 
          which would be distracting; also there is no <code>_cell</code> version
class:    lvar
level:    cell-exact
val:      positive_integer
doc:      TBD
brief:    number of cells
page:     enclone help lvars
avail:    public
notes:
code:     let counts = vec!["1.0".to_string(); mults[u]];
          cell: counts
          exact: format!("{}", mults[u])
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     n_NAME
inputs:   lvar_vdj
limits:   <code>PER_CELL</code>values are not displayed because they are all <code>1</code>,
          which would be distracting; also there is no <code>_cell</code> version</td></tr>
class:    lvar
level:    cell-exact
val:      nonnegative_integer
doc:      TBD
brief:    number of cells associated to the given name
page:     enclone help lvars
avail:    public
notes:
code:     let mut count = 0;
          let mut counts = Vec::<String>::new();
          for j in 0..ex.clones.len() {
              let x = &ex.clones[j][0];
              if ctl.origin_info.dataset_id[x.dataset_index] == name {
                  count += 1;
                  counts.push("1.0".to_string());
              } else if x.origin_index.is_some()
                  && ctl.origin_info.origin_list[x.origin_index.unwrap()] == name
              {
                  count += 1;
                  counts.push("1.0".to_string());
              } else if x.donor_index.is_some()
                  && ctl.origin_info.donor_list[x.donor_index.unwrap()] == name
              {
                  count += 1;
                  counts.push("1.0".to_string());
              } else if x.tag_index.is_some()
                  && ctl.origin_info.tag_list[x.tag_index.unwrap()] == name
              {
                  count += 1;
                  counts.push("1.0".to_string());
              }
          }
          cell: counts
          exact: format!("{}", count)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     n_b
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell-exact
val:      nonnegative_integer
doc:      TBD
brief:    number of B cells
page:     UNDOCUMENTED
avail:    private
notes:
code:     let mut n_b = 0;
          let mut ns = Vec::<String>::new();
          for j in 0..ex.clones.len() {
              let bc = &ex.clones[j][0].barcode;
              let li = ex.clones[j][0].dataset_index;
              if gex_info.cell_type[li].contains_key(&bc.clone()) {
                  if gex_info.cell_type[li][&bc.clone()].starts_with('B') {
                      n_b += 1;
                      ns.push("1.0".to_string());
                  } else {
                      ns.push("0.0".to_string());
                  }
              }
          }
          cell: ns
          exact: format!("{}", n_b)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     n_gex
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell-exact
val:      float
doc:      TBD
brief:    median number of cells seen by GEX pipeline
page:     enclone help lvars
avail:    public
notes:
code:     let mut n = Vec::<String>::new();
          let mut n_gex = 0;
          for x in n_gexs.iter() {
              n.push(format!("{}", *x));
              n_gex += *x;
          }
          cell: n
          exact: format!("{}", n_gex)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     n_other
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell-exact
val:      nonnegative_integer
doc:      TBD
brief:    when using nd<k>, the number of cells assigned to another dataset
page:     enclone help lvars
avail:    public
notes:
code:     let mut n = 0;
          let mut ns = Vec::<String>::new();
          for j in 0..ex.clones.len() {
              let mut found = false;
              let di = ex.clones[j][0].dataset_index;
              let f = format!("n_{}", ctl.origin_info.dataset_id[di]);
              for i in 0..nd_fields.len() {
                  if f == nd_fields[i] {
                      found = true;
                  }
              }
              if !found {
                  n += 1;
                  ns.push("1.0".to_string());
              } else {
                  ns.push("0.0".to_string());
              }
          }
          cell: ns
          exact: format!("{}", n)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     nbc
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell
val:      string
doc:      TBD
brief:    numeric barcode
page:     enclone help lvars
avail:    public
notes:
code:     let mut nbc = Vec::<String>::new();
          for j in 0..ex.clones.len() {
              let bc = ex.clones[j][0].barcode.before("-").as_bytes();
              let mut n = 0_u64;
              for k in 0..bc.len() {
                  if k > 0 {
                      n *= 4;
                  }
                  if bc[k] == b'C' {
                      n += 1;
                  } else if bc[k] == b'G' {
                      n += 2;
                  } else if bc[k] == b'T' {
                      n += 3;
                  }
              }
              nbc.push(format!("{:010}", n));
          }
          cell: nbc
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     nchains
inputs:   lvar_vdj
limits:
class:    lvar
level:    clono
val:      positive_integer
doc:      TBD
brief:    number of chains in the clonotype
page:     enclone help lvars
avail:    public
notes:
code:     exact: format!("{}", rsi.mat.len())
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     nchains_present
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      positive_integer
doc:      The number of chains that are present in a given exact subclonotype.
brief:    number of chains present in an exact subclonotype
page:     enclone help lvars
avail:    public
notes:
code:     exact: format!("{}", exact_clonotypes[exacts[u]].share.len())
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     ndiff{1..}vj
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    number of base differences with exact subclonotype of that number
page:     enclone help cvars
avail:    public
notes:
code:     let nd;
          let mat = &rsi.mat;
          let u0 = (arg1 - 1) as usize;
          if u0 < exacts.len() && mat[col][u0].is_some() && mat[col][u].is_some() {
              let m0 = mat[col][u0].unwrap();
              let m = mat[col][u].unwrap();
              let mut ndiff = 0;
              let ex0 = &exact_clonotypes[exacts[u0]];
              let ex = &exact_clonotypes[exacts[u]];
              for p in 0..ex0.share[m0].seq_del.len() {
                  if ex0.share[m0].seq_del[p] != ex.share[m].seq_del[p] {
                      ndiff += 1;
                  }
              }
              nd = format!("{}", ndiff)
          } else {
              nd = "_".to_string()
          }
          exact: nd
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     near
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    Hamming distance to nearest neighbor 
page:     enclone help lvars
avail:    public
notes:
code:     let near;
          let mut dist = 1_000_000;
          for i2 in 0..varmat.len() {
              if i2 == u || fp[i2] != fp[u] {
                  continue;
              }
              let mut d = 0;
              for c in fp[u].iter() {
                  for j in 0..varmat[u][*c].len() {
                      if varmat[u][*c][j] != varmat[i2][*c][j] {
                          d += 1;
                      }
                  }
              }
              dist = min(dist, d);
          }
          if dist == 1_000_000 {
              near = "".to_string()
          } else {
              near = format!("{}", dist)
          }
          exact: near
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     nival
inputs:   cvar_vdj
limits:
class:    cvar
level:    cell
val:      nonnegative_integer
doc:      TBD
brief:    number of invalidated UMIs
page:     UNDOCUMENTED
avail:    private
notes:
code:     let mut valsx = Vec::<String>::new();
          for k in 0..ex.ncells() {
              let mut n = 0;
              if ex.clones[k][mid].invalidated_umis.is_some() {
                  n = ex.clones[k][mid].invalidated_umis.as_ref().unwrap().len();
              }
              valsx.push(format!("{}", n));
          }
          cell: valsx
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     nnval
inputs:   cvar_vdj
limits:
class:    cvar
level:    cell
val:      nonnegative_integer
doc:      TBD
brief:    number of non-validated UMIs
page:     UNDOCUMENTED
avail:    private
notes:
code:     let mut valsx = Vec::<String>::new();
          for k in 0..ex.ncells() {
              let mut n = 0;
              if ex.clones[k][mid].non_validated_umis.is_some() {
                  n = ex.clones[k][mid].non_validated_umis.as_ref().unwrap().len();
              }
              valsx.push(format!("{}", n));
          }
          cell: valsx
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     notes
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    notes for exact subclonotype
page:     enclone help cvars
avail:    public
notes:
code:     exact: ex.share[mid].vs_notesx.clone()
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     npe
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell
val:      string
doc:      TBD
brief:    # of clonotype cells within PCA distance n of this cell
page:     UNDOCUMENTED
avail:    private
notes:
code:     exact: String::new()
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     nval
inputs:   cvar_vdj
limits:
class:    cvar
level:    cell
val:      nonnegative_integer
doc:      TBD
brief:    number of validated UMIs
page:     UNDOCUMENTED
avail:    private
notes:
code:     let mut valsx = Vec::<String>::new();
          for k in 0..ex.ncells() {
              let mut n = 0;
              if ex.clones[k][mid].validated_umis.is_some() {
                  n = ex.clones[k][mid].validated_umis.as_ref().unwrap().len();
              }
              valsx.push(format!("{}", n));
          }
          cell: valsx
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     nvalbcumis
inputs:   cvar_vdj
limits:
class:    cvar
level:    cell
val:      string
doc:      TBD
brief:    non-validated UMIs, preceded by barcode
page:     UNDOCUMENTED
avail:    private
notes:
code:     let mut vals = Vec::<String>::new();
          for k in 0..ex.ncells() {
              let mut n = String::new();
              if ex.clones[k][mid].non_validated_umis.is_some() {
                  let mut bc_umis = ex.clones[k][mid].non_validated_umis.clone().unwrap();
                  for i in 0..bc_umis.len() {
                      bc_umis[i] =
                          format!("{}{}", ex.clones[k][mid].barcode.before("-"), bc_umis[i]);
                  }
                  n = format!("{}", bc_umis.iter().format(","));
              }
              vals.push(n.to_string());
          }
          cell: vals
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     nvalumis
inputs:   cvar_vdj
limits:
class:    cvar
level:    cell
val:      string
doc:      TBD
brief:    non-validated UMIs
page:     UNDOCUMENTED
avail:    private
notes:
code:     let mut vals = Vec::<String>::new();
          for k in 0..ex.ncells() {
              let mut n = String::new();
              if ex.clones[k][mid].non_validated_umis.is_some() {
                  n = format!(
                      "{}",
                      ex.clones[k][mid]
                          .non_validated_umis
                          .as_ref()
                          .unwrap()
                          .iter()
                          .format(",")
                  );
              }
              vals.push(n.to_string());
          }
          cell: vals
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     origins
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell-exact
val:      string
doc:      TBD
brief:    origin names
page:     enclone help lvars
avail:    public
notes:
code:     let mut origins = Vec::<String>::new();
          for j in 0..ex.clones.len() {
              if ex.clones[j][0].origin_index.is_some() {
                  origins.push(
                      ctl.origin_info.origin_list[ex.clones[j][0].origin_index.unwrap()].clone(),
                  );
              } else {
                  origins.push("?".to_string());
              }
          }
          let origins_unsorted = origins.clone();
          unique_sort(&mut origins);
          cell: origins_unsorted
          exact: format!("{}", origins.iter().format(","))
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     pe
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell
val:      string
doc:      TBD
brief:    PCA equivalence class at distance ≤ n
page:     UNDOCUMENTED
avail:    private
notes:
code:     exact: String::new()
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     ppe
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell
val:      string
doc:      TBD
brief:    % of gex cells within PCA dist n of this cell that are in this clonotype
page:     UNDOCUMENTED
avail:    private
notes:
code:     exact: String::new()
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     q{0..}_
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    read quality scores at position <code>n</code>
page:     enclone help cvars
avail:    public
notes:
code:     let mut val = String::new();
          if (arg1 as usize) < ex.share[mid].seq.len() {
              let mut quals = Vec::<u8>::new();
              for j in 0..ex.clones.len() {
                  quals.push(ex.clones[j][mid].quals[arg1 as usize]);
              }
              val = format!("{}", quals.iter().format(","));
          }
          exact: val
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     r
inputs:   cvar_vdj
limits:
class:    cvar
level:    cell-exact
val:      float
doc:      TBD
brief:    median number of reads supporting chain
page:     enclone help cvars
avail:    public
notes:
code:     let mut nreads = Vec::<String>::new();
          let mut nreads_sorted = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              nreads.push(format!("{}", ex.clones[j][mid].read_count));
              nreads_sorted.push(ex.clones[j][mid].read_count);
          }
          nreads_sorted.sort_unstable();
          cell: nreads
          exact: format!("{}", rounded_median(&nreads_sorted))
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     r_max
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    maximum chain read count across exact subclonotype
page:     enclone help cvars
avail:    public
notes:
code:     let mut nreads = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              nreads.push(ex.clones[j][mid].read_count);
          }
          exact: format!("{}", *nreads.iter().max().unwrap())
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     r_mean
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      float
doc:      TBD
brief:    mean chain reads across exact subclonotype (= <code>r_μ</code>)
page:     enclone help cvars
avail:    public
notes:
code:     let mut nreads = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              nreads.push(ex.clones[j][mid].read_count);
          }
          let rtot: usize = nreads.iter().sum();
          let r_mean = (rtot as f64 / nreads.len() as f64).round() as usize;
          exact: format!("{}", r_mean)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     r_min
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    minimum chain read count across exact subclonotype
page:     enclone help cvars
avail:    public
notes:
code:     let mut nreads = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              nreads.push(ex.clones[j][mid].read_count);
          }
          exact: format!("{}", *nreads.iter().min().unwrap())
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     r_sum
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    sum of chain read counts across exact subclonotype (= <code>r_Σ</code>)
page:     enclone help cvars
avail:    public
notes:
code:     let mut nreads = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              nreads.push(ex.clones[j][mid].read_count);
          }
          let rtot: usize = nreads.iter().sum();
          exact: format!("{}", rtot)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     r_Σ
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    sum of chain reads across exact subclonotype (= <code>r_sum</code>)
page:     enclone help cvars
avail:    public
notes:
code:     let mut nreads = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              nreads.push(ex.clones[j][mid].read_count);
          }
          let rtot: usize = nreads.iter().sum();
          exact: format!("{}", rtot)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     r_μ
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      float
doc:      TBD
brief:    mean chain read count across exact subclonotype (= <code>r_μ</code>)
page:     enclone help cvars
avail:    public
notes:
code:     let mut nreads = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              nreads.push(ex.clones[j][mid].read_count);
          }
          let rtot: usize = nreads.iter().sum();
          let r_mean = (rtot as f64 / nreads.len() as f64).round() as usize;
          exact: format!("{}", r_mean)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     sec
inputs:   lvar_vdj
limits:
class:    lvar
level:    cell-exact
val:      nonnegative integer
doc:      TBD
brief:    for human or mouse BCR, number of GEX UMIs that are characterized as secreted
page:     UNDOCUMENTED
avail:    private
notes:
code:     let mut n = 0;
          let mut y = Vec::<String>::new();
          if ctl.gen_opt.using_secmem {
              for l in 0..ex.clones.len() {
                  let li = ex.clones[l][0].dataset_index;
                  let bc = &ex.clones[l][0].barcode;
                  let mut count = 0;
                  if ctl.origin_info.secmem[li].contains_key(&bc.clone()) {
                      count = ctl.origin_info.secmem[li][&bc.clone()].0;
                      n += count;
                  }
                  y.push(format!("{}", count));
              }
          }
          cell: y
          exact: format!("{}", n)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     seq
inputs:   ?
limits:   only implemented for parseable output
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    full nucleotide sequence of exact subclonotype
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     share_indices_aa
inputs:   ?
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    shared amino acid positions
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     share_indices_dna
inputs:   ?
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    shared nucleotide positions
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     type
inputs:   lvar_vdj
limits:
class:    lvar
level:    exact
val:      string
doc:      TBD
brief:    cell type
page:     UNDOCUMENTED
avail:    public
notes:
code:     let mut cell_types = Vec::<String>::new();
          /*
          for j in 0..ex.clones.len() {
              let mut cell_type = "".to_string();
              let bc = &ex.clones[j][0].barcode;
              let li = ex.clones[j][0].dataset_index;
              if gex_info.cell_type[li].contains_key(&bc.clone()) {
                  cell_type = gex_info.cell_type[li][&bc.clone()].clone();
              }       
              cell_types.push(cell_type);
          }       
          */          
          cell_types.sort();
          exact: abbrev_list(&cell_types)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     u
inputs:   cvar_vdj
limits:
class:    cvar
level:    cell-exact
val:      nonnegative_integer
doc:      TBD
brief:    median number of UMIs supporting chain
page:     enclone help cvars
avail:    public
notes:
code:     let mut numis = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              numis.push(ex.clones[j][mid].umi_count);
          }
          numis.sort_unstable();
          let median_numis = rounded_median(&numis);
          let mut vals = Vec::<String>::new();
          for k in 0..ex.ncells() {
              vals.push(format!("{}", ex.clones[k][mid].umi_count));
          }
          cell: vals
          exact: format!("{}", median_numis)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     u_max
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      For a chain in an exact subclonotype, the maximum number of UMIs, ranging across the 
          cells.
brief:    maximum chain UMIs across exact subclonotype
page:     enclone help cvars
avail:    public
notes:
code:     let mut numis = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              numis.push(ex.clones[j][mid].umi_count);
          }
          numis.sort_unstable();
          exact: format!("{}", numis.iter().max().unwrap())
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     u_mean
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      float
doc:      TBD
brief:    mean chain UMIs across exact subclonotype (= <code>u_μ</code>) 
page:     enclone help cvars
avail:    public
notes:
code:     let mut numis = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              numis.push(ex.clones[j][mid].umi_count);
          }
          numis.sort_unstable();
          let utot: usize = numis.iter().sum();
          let u_mean = (utot as f64 / numis.len() as f64).round() as usize;
          exact: format!("{}", u_mean)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     u_min
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    minimum chain UMIs across exact subclonotype
page:     enclone help cvars
avail:    public
notes:
code:     let mut numis = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              numis.push(ex.clones[j][mid].umi_count);
          }
          numis.sort_unstable();
          exact: format!("{}", numis.iter().min().unwrap())
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     u_sum
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    sum of chain UMIs for exact subclonotype (= <code>u_Σ</code>)
page:     enclone help cvars
avail:    public
notes:
code:     let mut numis = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              numis.push(ex.clones[j][mid].umi_count);
          }
          let utot: usize = numis.iter().sum();
          exact: format!("{}", utot)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     u_Σ
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    sum of chain UMIs across exact subclonotype (= <code>u_sum</code>)
page:     enclone help cvars
avail:    public
notes:
code:     let mut numis = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              numis.push(ex.clones[j][mid].umi_count);
          }
          let utot: usize = numis.iter().sum();
          exact: format!("{}", utot)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     u_μ
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      float
doc:      TBD
brief:    mean chain UMIs for exact subclonotype (= <code>u_mean</code>)
page:     enclone help cvars
avail:    public
notes:
code:     let mut numis = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              numis.push(ex.clones[j][mid].umi_count);
          }
          numis.sort_unstable();
          let utot: usize = numis.iter().sum();
          let u_mean = (utot as f64 / numis.len() as f64).round() as usize;
          exact: format!("{}", u_mean)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     udiff
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    differences of 5'-UTR region with universal reference
page:     enclone help cvars
avail:    public
notes:
code:     let ulen = ex.share[mid].v_start;
          let uid = ex.share[mid].u_ref_id;
          let mut udiff = String::new();
          let mut ndiffs = 0;
          if uid.is_some() {
              let r = &refdata.refs[uid.unwrap()];
              let mut extra = 0;
              if ulen > r.len() {
                  extra = ulen - r.len();
              }
              for i in 0..ulen {
                  let mut rpos = i;
                  if ulen < r.len() {
                      rpos += r.len() - ulen;
                  } else {
                      if i + r.len() < ulen {
                          continue;
                      }
                      rpos -= ulen - r.len();
                  }
                  let tb = ex.share[mid].full_seq[i];
                  let rb = r.to_ascii_vec()[rpos];
                  if tb != rb {
                      ndiffs += 1;
                      if ndiffs <= 5 {
                          udiff += &format!("{}{}", rpos, tb as char);
                      }
                  }
              }
              if ndiffs > 5 {
                  udiff += "...";
              }
              if extra > 0 {
                  udiff += &format!("+{}", extra);
              }
          } else if ulen > 0 {
              udiff = format!("+{}", ulen);
          }
          exact: udiff
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     ulen
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    length of observed 5'-UTR sequence 
page:     enclone help cvars
avail:    public
notes:
code:     exact: format!("{}", ex.share[mid].v_start)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     utr_id
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      positive_integer
doc:      TBD
brief:    numerical identifier of 5'-UTR region (or null)
page:     enclone help parseable
avail:    public
notes:
code:     let mut u = String::new();
          let uid = ex.share[mid].u_ref_id;
          if uid.is_some() {
              u = format!("{}", refdata.id[uid.unwrap()]);
          }
          exact: u
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     utr_name
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    name of 5'-UTR region (or null)
page:     enclone help parseable
avail:    public
notes:
code:     let mut u = String::new();
          let uid = ex.share[mid].u_ref_id;
          if uid.is_some() {
              u = refdata.name[uid.unwrap()].clone();
          }
          exact: u
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     v_id
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      positive_integer
doc:      TBD
brief:    V region id
page:     enclone help parseable
avail:    public
notes:
code:     exact: format!("{}", refdata.id[rsi.vids[col]])
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     v_name
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    V region name
page:     enclone help cvars
avail:    public
notes:
code:     exact: refdata.name[rsi.vids[col]].clone()
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     v_name_orig
inputs:   cvar_vdj
limits:
class:    cvar
level:    cell-exact
val:      string
doc:      TBD
brief:    V region name that was originally assigned
page:     enclone help cvars
avail:    public
notes:
code:     let mut vals = Vec::<String>::new();
          for k in 0..ex.ncells() {
              vals.push(refdata.name[ex.clones[k][mid].v_ref_id].clone());
          }
          let mut vals_uniq = vals.clone();
          unique_sort(&mut vals_uniq);
          cell: vals
          exact: format!("{}", vals_uniq.iter().format(","))
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     v_start
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      positive_integer_or_null
doc:      TBD
brief:    start of V on full nucleotide sequence
page:     enclone help parseable
avail:    public
notes:    Positive integer, or nonnegative integer?
code:     exact: format!("{}", ex.share[mid].v_start)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     valbcumis
inputs:   cvar_vdj
limits:
class:    cvar
level:    cell
val:      string
doc:      TBD
brief:    validated UMIs, preceded by barcode
page:     UNDOCUMENTED
avail:    private
notes:
code:     let mut vals = Vec::<String>::new();
          for k in 0..ex.ncells() {
              let mut n = String::new();
              if ex.clones[k][mid].validated_umis.is_some() {
                  let mut bc_umis = ex.clones[k][mid].validated_umis.clone().unwrap();
                  for i in 0..bc_umis.len() {
                      bc_umis[i] =
                          format!("{}{}", ex.clones[k][mid].barcode.before("-"), bc_umis[i]);
                  }
                  n = format!("{}", bc_umis.iter().format(","));
              }
              vals.push(n.to_string());
          }
          cell: vals
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     valumis
inputs:   cvar_vdj
limits:
class:    cvar
level:    cell
val:      string
doc:      TBD
brief:    validated UMIs
page:     UNDOCUMENTED
avail:    private
notes:
code:     let mut vals = Vec::<String>::new();
          for k in 0..ex.ncells() {
              let mut n = String::new();
              if ex.clones[k][mid].validated_umis.is_some() {
                  n = format!(
                      "{}",
                      ex.clones[k][mid]
                          .validated_umis
                          .as_ref()
                          .unwrap()
                          .iter()
                          .format(",")
                  );
              }
              vals.push(n.to_string());
          }
          cell: vals
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     var
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    bases at position in chain that vary across the clonotype
page:     enclone help cvars
avail:    public
notes:
code:     exact: stringme(&varmat[u][col])
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     var_aa
inputs:   ?
limits:   only implemented for parseable output
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    variant residue indices in clonotype (including synonymous)
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     var_indices_aa
inputs:   ?
limits:   only implemented for parseable output
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    variable amino acid positions
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     var_indices_dna
inputs:   ?
limits:   only implemented for parseable output
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    variable nucleotide positions
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     vj_aa
inputs:   ?
limits:   only implemented for parseable output
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    amino acid sequence of V..J
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     vj_aa_nl
inputs:   ?
limits:   only implemented for parseable output
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    amino acid sequence of V..J, excluding leader
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     vj_seq
inputs:   ?
limits:   only implemented for parseable output
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    nucleotide sequence of V..J
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     vj_seq_nl
inputs:   ?
limits:   only implemented for parseable output
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    nucleotide sequence of V..J, excluding leader
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     vjlen
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      positive_integer
doc:      TBD
brief:    length in bases of V..J
page:     enclone help cvars
avail:    public
notes:
code:     exact: format!("{}", ex.share[mid].j_stop - ex.share[mid].v_start)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     white
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      float
doc:      TBD
brief:    percent of sequences implicated in whitelist expansion
page:     UNDOCUMENTED
avail:    private
notes:
code:     let mut bch = vec![Vec::<(usize, String, usize, usize)>::new(); 2];
          for l in 0..ex.clones.len() {
              let li = ex.clones[l][0].dataset_index;
              let bc = &ex.clones[l][0].barcode;
              let mut numi = 0;
              for j in 0..ex.clones[l].len() {
                  numi += ex.clones[l][j].umi_count;
              }
              bch[0].push((li, bc[0..8].to_string(), numi, l));
              bch[1].push((li, bc[8..16].to_string(), numi, l));
          }
          let mut junk = 0;
          let mut bad = vec![false; ex.clones.len()];
          for l in 0..2 {
              bch[l].sort();
              let mut m = 0;
              while m < bch[l].len() {
                  let n = next_diff12_4(&bch[l], m as i32) as usize;
                  for u1 in m..n {
                      for u2 in m..n {
                          if bch[l][u1].2 >= 10 * bch[l][u2].2 {
                              bad[bch[l][u2].3] = true;
                          }
                      }
                  }
                  m = n;
              }
          }
          for u in 0..bad.len() {
              if bad[u] {
                  junk += 1;
              }
          }
          let junk_rate = percent_ratio(junk, ex.clones.len());
          exact: format!("{:.1}", junk_rate)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
