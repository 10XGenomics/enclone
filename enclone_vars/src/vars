# Copyright (c) 2021 10X Genomics, Inc. All rights reserved.
#
# This is the start of a variable registry for enclone.  Every variable must specify all the
# following fields, in the same order.  
#
# The exact formatting as exhibited by existing variables # must be followed.  This includes
# indentation.
#
# name:     name of the variable, which may include special strings so as to represent
#           variable classes; this excludes the chain number suffix (1,...) for cvars.
#
#           Upper case characters always define variable class strings.  The following are
#           recognized:
#           BC         user-defined variable from BC or META/bc
#           DATASET    name of a dataset
#           FEATURE    name of a feature
#           INFO       user-defined variable from INFO
#           NAME       name, see n_<name> at enclone help lvars
#           REG        regular expression.
#           VARDEF     user-defined variable from VAR_DEF
#
# inputs:   data structures needed as input
#           ex: ExactClonotype = exact subclonotype structure
#           mid: usize = chain id in clonotype
#           refdata
#           fm: gex_info.feature_metrics = feature values by barcode
#           col
#           exacts
#           exact_clonotypes
#           rsi
#
# limits:   limitations on availability of the variable
#
# class:    lvar or cvar
#
# level:    scope of the variable, one of
#           cell, cell-exact, exact, clono, dataset, global
#
# val:      the type of the value, one of
#           positive_integer, float[0,100].precision(1)
#
# doc:      documentation
#
# brief:    brief documentation, for use in compact html tables
#
# page:     reference page
#
# avail:    availability, public or private or ? (temp)
#
# notes:    things to clarify
#
# code:     code for computing the variable value

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     BC
inputs:   ?
limits:
class:    lvar
level:    cell
val:      string
doc:      TBD
brief:    user-defined variable from BC or META/bc
page:     enclone help input
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     DATASET_barcode
inputs:   ?
limits:   only implemented for parseable output
class:    lvar
level:    cell
val:      string
doc:      TBD
brief:    barcode from the given dataset (or null)
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     DATASET_barcodes
inputs:   ?
limits:   only implemented for parseable output
class:    lvar
level:    exact
val:      string
doc:      TBD
brief:    barcodes from the given dataset
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE
inputs:   ?
limits:
class:    lvar
level:    cell-exact
val:      float
doc:      TBD
brief:    median count for a gene expression or antibody feature
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_%
inputs:   ?
limits:
class:    lvar
level:    cell-exact
val:      float[0,100].precision(1)
doc:      TBD
brief:    median percent of total expression for a particular gene
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_%_cell
inputs:   ?
limits:
class:    lvar
level:    cell
val:      float[0,100].precision(1)
doc:      TBD
brief:    percent of total expression for a particular gene
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_cell
inputs:   ?
limits:
class:    lvar
level:    cell
val:      nonnegative_integer
doc:      TBD
brief:    count for a gene expression or antibody feature
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_cellular_r
inputs:   fm
limits:
class:    lvar
level:    dataset
val:      float[0,100].precision(1)
doc:      For a given feature, the percent of reads that are identified by the
          cellranger pipeline as lying in a cell.
brief:    percent of feature reads in cells, for a given dataset
page:     enclone help display
avail:    ?
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_cellular_u
inputs:   fm
limits:
class:    lvar
level:    dataset
val:      float[0,100].precision(1)
doc:      For a given feature, the percent of UMIs that are identified by the
          cellranger pipeline as lying in a cell.
brief:    percent of feature UMIs in cells, for a given dataset
page:     enclone help display
avail:    ?
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_max
inputs:   ?
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    maximum count for a feature
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_mean
inputs:   ?
limits:
class:    lvar
level:    exact
val:      float
doc:      TBD
brief:    mean count for a feature (same as <code>μ</code> for <code>mean</code>)
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_min
inputs:   ?
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    minimum count for a feature 
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_sum
inputs:   ?
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    sum of counts for a feature (same as <code>Σ</code> for <code>sum</code>)
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_Σ
inputs:   ?
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    sum of counts for a feature (same as <code>sum</code> for <code>Σ</code>)
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     FEATURE_μ
inputs:   ?
limits:
class:    lvar
level:    exact
val:      float
doc:      TBD
brief:    mean count for a feature (same with <code>mean</code> for <code>μ</code>)
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     INFO
inputs:   ?
limits:
class:    lvar
level:    exact
val:      string
doc:      TBD
brief:    user-defined variable from INFO
page:     enclone help input
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     VARDEF
inputs:   ?
limits:
class:    lvar
level:    cell-exact
val:      string
doc:      TBD
brief:    user-defined variable from VAR_DEF
page:     enclone help input
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     aa%
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      float[0,100].precision(1)
doc:      TBD
brief:    amino acid identity with donor reference
page:     enclone help cvars
avail:    public
notes:
code:     let xm = &ex.share[mid];
          let mut diffs = 0;
          let mut denom = 0;
          let aa_seq = &xm.aa_mod_indel;
          let mut vref = refdata.refs[xm.v_ref_id].to_ascii_vec();
          if xm.v_ref_id_donor_alt_id.is_some() {
              vref = dref[xm.v_ref_id_donor.unwrap()].nt_sequence.clone();
          }
          let jref = refdata.refs[xm.j_ref_id].to_ascii_vec();
          let z = 3 * aa_seq.len() + 1;
          for p in 0..aa_seq.len() {
              if aa_seq[p] == b'-' {
                  diffs += 1;
                  denom += 1;
                  continue;
              }
              if 3 * p + 3 <= vref.len() - ctl.heur.ref_v_trim {
                  denom += 1;
                  if aa_seq[p] != codon_to_aa(&vref[3 * p..3 * p + 3]) {
                      diffs += 1;
                  }
              }
              if 3 * p > z - (jref.len() - ctl.heur.ref_j_trim) + 3 {
                  denom += 1;
                  if aa_seq[p]
                      != codon_to_aa(&jref[jref.len() - (z - 3 * p)..jref.len() - (z - 3 * p) + 3])
                  {
                      diffs += 1;
                  }
              }
          }
          format!("{:.1}", percent_ratio(denom - diffs, denom))
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     barcode
inputs:   ?
limits:   only implemented for parseable output, and as an automatic field for clonotype tables in 
          PER_CELL mode
class:    lvar
level:    cell
val:      string
doc:      TBD
brief:    barcode of the cell
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     barcodes
inputs:   ?
limits:   only implemented for parseable output
class:    lvar
level:    exact
val:      string
doc:      TBD
brief:    barcodes for the exact subclonotype
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdiff
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    differences of const region with universal reference
page:     enclone help cvars
avail:    public
notes:
code:     let cstart = ex.share[mid].j_stop;
          let clen = ex.share[mid].full_seq.len() - cstart;
          let cid = ex.share[mid].c_ref_id;
          let mut cdiff = String::new();
          let mut ndiffs = 0;
          if cid.is_some() {
              let r = &refdata.refs[cid.unwrap()];
              let mut extra = 0;
              if clen > r.len() {
                  extra = clen - r.len();
              }
              for i in 0..min(clen, r.len()) {
                  let tb = ex.share[mid].full_seq[cstart + i];
                  let rb = r.to_ascii_vec()[i];
                  if tb != rb {
                      ndiffs += 1;
                      if ndiffs <= 5 {
                          cdiff += &format!("{}{}", i, tb as char);
                      }
                  }
              }
              if ndiffs > 5 {
                  cdiff += "...";
              }
              if extra > 0 {
                  cdiff += &format!("+{}", extra);
              }
          } else if clen > 0 {
              cdiff = format!("+{}", clen);
          }
          cdiff
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr*_aa_{0..}_{0..}_ext
inputs:   ?
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    CDR* region with specified extension length
page:     enclone help cvars
avail:    public
notes:    Check if args are really nonnegative integers.
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr3_aa_conp
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    CDR3 amino acid consensus, symbols at variants
page:     enclone help cvars
avail:    public
notes:
code:     cdr3_aa_con("p", col, exacts, exact_clonotypes, rsi)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr3_aa_conx
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    CDR3 amino acid clonotype consensus, Xs at variants
page:     enclone help cvars
avail:    public
notes:
code:     cdr3_aa_con("x", col, exacts, exact_clonotypes, rsi)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr3_start
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      positive_integer
doc:      TBD
brief:    nucleotide start of CDR3 sequence on full sequence
page:     enclone help parseable
avail:    public
notes:    Check if type is really positive integer.
code:     ex.share[mid].cdr3_start.to_string()
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr{1..2}_aa_ref
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    CDR* amino acid sequence for universal reference
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          if arg1 == 1 {
              if x.cdr1_start.is_some()
                  && x.fr2_start.is_some()
                  && x.cdr1_start.unwrap() <= x.fr2_start.unwrap()
              {
                  let dna = refdata.refs[x.v_ref_id].to_ascii_vec()
                      [x.cdr1_start.unwrap()..x.fr2_start.unwrap()]
                      .to_vec();
                  y = stringme(&aa_seq(&dna, 0));
              }
          } else {
              if x.cdr2_start.is_some()
                  && x.fr3_start.is_some()
                  && x.cdr2_start.unwrap() <= x.fr3_start.unwrap()
              {
                  let dna = refdata.refs[x.v_ref_id].to_ascii_vec()
                      [x.cdr2_start.unwrap()..x.fr3_start.unwrap()]
                      .to_vec();
                  y = stringme(&aa_seq(&dna, 0));
              }
          }
          y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr{1..2}_dna_ref
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    CDR* nucleotide sequence for universal reference
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          if arg1 == 1 {
              if x.cdr1_start.is_some()
                  && x.fr2_start.is_some()
                  && x.cdr1_start.unwrap() <= x.fr2_start.unwrap()
              {
                  let dna = refdata.refs[x.v_ref_id].to_ascii_vec()
                      [x.cdr1_start.unwrap()..x.fr2_start.unwrap()]
                      .to_vec();
                  y = stringme(&dna);
              }
          } else {
              if x.cdr2_start.is_some()
                  && x.fr3_start.is_some()
                  && x.cdr2_start.unwrap() <= x.fr3_start.unwrap()
              {
                  let dna = refdata.refs[x.v_ref_id].to_ascii_vec()
                      [x.cdr2_start.unwrap()..x.fr3_start.unwrap()]
                      .to_vec();
                  y = stringme(&dna);
              }
          }
          y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr{1..3}_aa
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    CDR* amino acid sequence
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          let c;
          if arg1 == 1 {
              c = get_cdr1(&x, 0, 0);
              if c.is_some() {
                  y = stringme(&aa_seq(c.unwrap().as_bytes(), 0));
              }
          } else if arg1 == 2 {
              c = get_cdr2(&x, 0, 0);
              if c.is_some() {
                  y = stringme(&aa_seq(c.unwrap().as_bytes(), 0));
              }
          } else {
              y = x.cdr3_aa.clone();
          }
          y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr{1..3}_aa_north
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    North version of CDR* amino acid sequence
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          let c;
          if arg1 == 1 {
              let (mut left, mut right) = (0, 0);
              if x.left {
                  left = 3;
                  right = 3;
              }
              c = get_cdr1(&x, left, right);
              if c.is_some() {
                  y = stringme(&aa_seq(c.unwrap().as_bytes(), 0));
              }
          } else if arg1 == 2 {
              let (left, right);
              if ex.share[mid].left {
                  left = 2;
                  right = 3;
              } else {
                  left = 1;
                  right = 0;
              }
              c = get_cdr2(&x, left, right);
              if c.is_some() {
                  y = stringme(&aa_seq(c.unwrap().as_bytes(), 0));
              }
          } else {
              c = get_cdr3(&x, -1, -1);
              if c.is_some() {
                  y = stringme(&aa_seq(c.unwrap().as_bytes(), 0));
              }
          }
          y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr{1..3}_aa_{0..}_{0..}_ext
inputs:   ?
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    CDR* region with specified extension length
page:     enclone help cvars
avail:    public
notes:    Do extension lengths start at zero?
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr{1..3}_dna
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    CDR* nucleotide sequence
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          let c;
          if arg1 == 1 {
              c = get_cdr1(&x, 0, 0);
          } else if arg1 == 2 {
              c = get_cdr2(&x, 0, 0);
          } else {
              c = Some(x.cdr3_dna.clone());
          }
          if c.is_some() {
              y = c.unwrap();
          }
          y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cdr{1..3}_len
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      positive_integer
doc:      TBD
brief:    length of CDR* amino acid sequence 
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          let c;
          if arg1 == 1 {
              c = get_cdr1(&x, 0, 0);
          } else if arg1 == 2 {
              c = get_cdr2(&x, 0, 0);
          } else {
              c = Some(x.cdr3_dna.clone());
          }
          if c.is_some() {
              y = format!("{}", c.unwrap().len() / 3);
          }
          y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     clen
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    length of observed constant region
page:     enclone help cvars
avail:    public
notes:
code:     format!("{}", ex.share[mid].full_seq.len() - ex.share[mid].j_stop)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     clonotype_id
inputs:   ?
limits:   only implemented for parseable output
class:    lvar
level:    clono
val:      positive_integer
doc:      TBD
brief:    identifier of clonotype within clonotype group 
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     clonotype_ncells
inputs:   ?
limits:
class:    lvar
level:    clono
val:      positive_integer
doc:      TBD
brief:    number of cells in the clonotype
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     comp
inputs:   ?
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    CDR3 complexity number
page:     enclone help cvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     const
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    constant region name
page:     enclone help cvars
avail:    public
notes:
code:     let mut constx = Vec::<String>::new();
          let cid = ex.share[mid].c_ref_id;
          if cid.is_some() {
              constx.push(refdata.name[cid.unwrap()].clone());
          } else {
              constx.push("?".to_string());
          }
          unique_sort(&mut constx);
          // This is overcomplicated because there is now at most one
          // const entry per exact subclonotype.
          format!("{}", constx.iter().format(","))
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     const_id
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      positive_integer_or_null
doc:      TBD
brief:    numerical identifier of constant region (or null)
page:     enclone help parseable
avail:    public
notes:
code:     let mut const_id = String::new();
          if ex.share[mid].c_ref_id.is_some() {
              const_id = format!("{}", refdata.id[ex.share[mid].c_ref_id.unwrap()]);
          }
          const_id
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     count_REG
inputs:   ?
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    count amino acid motifs
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cred
inputs:   ?
limits:
class:    lvar
level:    cell-exact
val:      float
doc:      TBD
brief:    median credibility assessed using GEX data
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     cred_cell
inputs:   ?
limits:
class:    lvar
level:    cell
val:      float
doc:      TBD
brief:    credibility assessed using GEX data
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d1_name
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    optimal D segment name
page:     enclone help cvars
avail:    public
notes:
code:     if !ex.share[mid].left {
              String::new()
          } else {
              let mut scores = Vec::<f64>::new();
              let mut ds = Vec::<Vec<usize>>::new();
              opt_d(ex, col, u, rsi, refdata, dref, &mut scores, &mut ds, ctl);
              let mut opt = Vec::new();
              if !ds.is_empty() {
                  opt = ds[0].clone();
              }
              let mut opt_name = String::new();
              if opt.is_empty() {
                  opt_name = "none".to_string();
              } else {
                  for i in 0..opt.len() {
                      if i > 0 {
                          opt_name += ":";
                      }
                      opt_name += &refdata.name[opt[i]];
                  }
              }
              opt_name
          }
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d1_score
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      float
doc:      TBD
brief:    score of optimal D segment
page:     enclone help cvars
avail:    public
notes:
code:     if !ex.share[mid].left {
              String::new()
          } else {
              let mut scores = Vec::<f64>::new();
              let mut ds = Vec::<Vec<usize>>::new();
              opt_d(ex, col, u, rsi, refdata, dref, &mut scores, &mut ds, ctl);
              let mut delta = 0.0;
              if scores.len() > 1 {
                  delta = scores[0] - scores[1];
              }
              format!("{:.1}", delta)
          }
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d2_name
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    second best D segment name
page:     enclone help cvars
avail:    public
notes:
code:     if !ex.share[mid].left {
              String::new()
          } else {
              let mut scores = Vec::<f64>::new();
              let mut ds = Vec::<Vec<usize>>::new();
              opt_d(ex, col, u, rsi, refdata, dref, &mut scores, &mut ds, ctl);
              let mut opt2 = Vec::new();
              if ds.len() > 1 {
                  opt2 = ds[1].clone();
              }
              let mut opt2_name = String::new();
              if opt2.is_empty() {
                  opt2_name = "none".to_string();
              } else {
                  for i in 0..opt2.len() {
                      if i > 0 {
                          opt2_name += ":";
                      }
                      opt2_name += &refdata.name[opt2[i]];
                  }
              }
              opt2_name
          }
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d2_score
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      float
doc:      TBD
brief:    score of second best D segment
page:     enclone help cvars
avail:    public
notes:
code:     if !ex.share[mid].left {
              String::new()
          } else {
              let mut scores = Vec::<f64>::new();
              let mut ds = Vec::<Vec<usize>>::new();
              opt_d(ex, col, u, rsi, refdata, dref, &mut scores, &mut ds, ctl);
              let mut score = 0.0;
              if scores.len() > 1 {
                  score = scores[1];
              }
              format!("{:.1}", score)
          }
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d_delta
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      float
doc:      TBD
brief:    score delta between top two D gene assignments
page:     enclone help cvars
avail:    public
notes:
code:     if !ex.share[mid].left {
              String::new()
          } else {
              let mut scores = Vec::<f64>::new();
              let mut ds = Vec::<Vec<usize>>::new();
              opt_d(ex, col, u, rsi, refdata, dref, &mut scores, &mut ds, ctl);
              let mut delta = 0.0;
              if scores.len() > 1 {
                  delta = scores[0] - scores[1];
              }
              format!("{:.1}", delta)
          }
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d_donor
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    distance from donor reference
page:     enclone help cvars
avail:    public
notes:
code:     let vid = ex.share[mid].v_ref_id;
          let mut vref = refdata.refs[vid].to_ascii_vec();
          if rsi.vpids[col].is_some() {
              vref = dref[rsi.vpids[col].unwrap()].nt_sequence.clone();
          }
          let jid = ex.share[mid].j_ref_id;
          let jref = &refdata.refs[jid].to_ascii_vec();
          let tig = &ex.share[mid].seq_del;
          let n = tig.len();
          let mut diffs = 0;
          for p in 0..n {
              if tig[p] == b'-' {
                  continue;
              }
              if p < vref.len() - ctl.heur.ref_v_trim && tig[p] != vref[p] {
                  diffs += 1;
              } else if p >= n - (jref.len() - ctl.heur.ref_j_trim)
                  && tig[p] != jref[jref.len() - (n - p)]
              {
                  diffs += 1;
              }
          }
          format!("{}", diffs)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d_frame
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    reading frame of D segment (0, 1, 2 or null)
page:     enclone help parseable
avail:    public
notes:
code:     let mut d_frame = String::new();
          if ex.share[mid].d_start.is_some() {
              d_frame = format!(
                  "{}",
                  (ex.share[mid].d_start.unwrap() - ex.share[mid].v_start) % 3
              );
          }
          d_frame
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d_id
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      positive_integer
doc:      TBD
brief:    D region id
page:     enclone help parseable
avail:    public
notes:
code:     let did = if rsi.dids[col].is_some() {
              format!("{}", refdata.id[rsi.dids[col].unwrap()])
          } else {
              String::new()
          };
          did
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d_inconsistent_%
inputs:   ?
limits:
class:    lvar
level:    global
val:      float[0,100].precision(1)
doc:      TBD
brief:    inconsistency percent for D gene assignment
page:     d_genes.html
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d_inconsistent_n
inputs:   ?
limits:
class:    lvar
level:    global
val:      positive_integer
doc:      TBD
brief:    sample size for computation of <code>d_inconsistent_%</code> 
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d_name
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    D region name
page:     enclone help parseable
avail:    public
notes:
code:     let dname = if rsi.dids[col].is_some() {
              refdata.name[rsi.dids[col].unwrap()].clone()
          } else {
              String::new()
          };
          dname
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d_start
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    start of D on full nucleotide sequence (or null)
page:     enclone help parseable
avail:    public
notes:    Starts at 0 or 1?
code:     let mut d_start = String::new();
          if ex.share[mid].d_start.is_some() {
              d_start = format!("{}", ex.share[mid].d_start.unwrap());
          }
          d_start
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d_univ
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    distance from universal reference
page:     enclone help cvars
avail:    public
notes:
code:     let vid = ex.share[mid].v_ref_id;
          let vref = &refdata.refs[vid].to_ascii_vec();
          let jid = ex.share[mid].j_ref_id;
          let jref = &refdata.refs[jid].to_ascii_vec();
          let tig = &ex.share[mid].seq_del;
          let n = tig.len();
          let mut diffs = 0;
          for p in 0..n {
              if tig[p] == b'-' {
                  continue;
              }
              if p < vref.len() - ctl.heur.ref_v_trim && tig[p] != vref[p] {
                  diffs += 1;
              } else if p >= n - (jref.len() - ctl.heur.ref_j_trim)
                  && tig[p] != jref[jref.len() - (n - p)]
              {
                  diffs += 1;
              }
          }
          format!("{}", diffs)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     d_Δ
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      float
doc:      TBD
brief:    score delta between top two D gene assignments
page:     enclone help cvars
avail:    public
notes:
code:     if !ex.share[mid].left {
              String::new()
          } else {
              let mut scores = Vec::<f64>::new();
              let mut ds = Vec::<Vec<usize>>::new();
              opt_d(ex, col, u, rsi, refdata, dref, &mut scores, &mut ds, ctl);
              let mut delta = 0.0;
              if scores.len() > 1 {
                  delta = scores[0] - scores[1];
              }
              format!("{:.1}", delta)
          }
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     datasets
inputs:   ?
limits:
class:    lvar
level:    cell-exact
val:      string
doc:      TBD
brief:    dataset names
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     datasets_cell
inputs:   ?
limits:
class:    lvar
level:    cell
val:      string
doc:      TBD
brief:    dataset name
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     dna%
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      float[0,100].precision(1)
doc:      TBD
brief:    nucleotide identity with donor reference
page:     enclone help cvars
avail:    public
notes:
code:     let xm = &ex.share[mid];
          let mut diffs = 0;
          let mut denom = 0;
          let seq = &xm.seq_del_amino;
          let mut vref = refdata.refs[xm.v_ref_id].to_ascii_vec();
          if xm.v_ref_id_donor_alt_id.is_some() {
              vref = dref[xm.v_ref_id_donor.unwrap()].nt_sequence.clone();
          }
          let jref = refdata.refs[xm.j_ref_id].to_ascii_vec();
          let z = seq.len();
          for p in 0..z {
              let b = seq[p];
              if b == b'-' {
                  diffs += 1;
                  denom += 1;
                  continue;
              }
              if p < vref.len() - ctl.heur.ref_v_trim {
                  denom += 1;
                  if b != vref[p] {
                      diffs += 1;
                  }
              }
              if p >= z - (jref.len() - ctl.heur.ref_j_trim) {
                  denom += 1;
                  if b != jref[jref.len() - (z - p)] {
                      diffs += 1;
                  }
              }
          }
          format!("{:.1}", percent_ratio(denom - diffs, denom))
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     donors
inputs:   ?
limits:
class:    lvar
level:    cell-exact
val:      string
doc:      TBD
brief:    donor names
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     donors_cell
inputs:   ?
limits:
class:    lvar
level:    cell
val:      string
doc:      TBD
brief:    donor name
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     dref
inputs:   cols, mat, u, ex, refdata, rsi, dref, ctl
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    nucleotide distance to donor reference
page:     enclone help lvars
avail:    public
notes:
code:
          let mut diffs = 0;
          for m in 0..cols {
              if mat[m][u].is_some() {
                  let r = mat[m][u].unwrap();
                  let seq = &ex.share[r].seq_del_amino;
                  let mut vref = refdata.refs[rsi.vids[m]].to_ascii_vec();
                  if rsi.vpids[m].is_some() {
                      vref = dref[rsi.vpids[m].unwrap()].nt_sequence.clone();
                  }
                  let jref = refdata.refs[rsi.jids[m]].to_ascii_vec();
                  let z = seq.len();
                  for p in 0..z {
                      let b = seq[p];
                      if p < vref.len() - ctl.heur.ref_v_trim && b != vref[p] {
                          diffs += 1;
                      }
                      if p >= z - (jref.len() - ctl.heur.ref_j_trim)
                          && b != jref[jref.len() - (z - p)]
                      {
                          diffs += 1;
                      }
                  }
              }
          }
          format!("{}", diffs)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     dref_aa
inputs:   cols, mat, u, ex, refdata, rsi, dref, ctl
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    amino acid distance to donor reference
page:     enclone help lvars
avail:    public
notes:
code:     let mut diffs = 0;
          for m in 0..cols {
              if mat[m][u].is_some() {
                  let r = mat[m][u].unwrap();
                  let aa_seq = &ex.share[r].aa_mod_indel;
                  let mut vref = refdata.refs[rsi.vids[m]].to_ascii_vec();
                  if rsi.vpids[m].is_some() {
                      vref = dref[rsi.vpids[m].unwrap()].nt_sequence.clone();
                  }
                  let jref = refdata.refs[rsi.jids[m]].to_ascii_vec();
                  let z = 3 * aa_seq.len() + 1;
                  for p in 0..aa_seq.len() {
                      if aa_seq[p] == b'-' {
                          diffs += 1;
                          continue;
                      }
                      if 3 * p + 3 <= vref.len() - ctl.heur.ref_v_trim
                          && aa_seq[p] != codon_to_aa(&vref[3 * p..3 * p + 3])
                      {
                          diffs += 1;
                      }
                      if 3 * p > z - (jref.len() - ctl.heur.ref_j_trim) + 3
                          && aa_seq[p]
                              != codon_to_aa(
                                  &jref[jref.len() - (z - 3 * p)..jref.len() - (z - 3 * p) + 3],
                              )
                      {
                          diffs += 1;
                      }
                  }
              }
          }
          format!("{}", diffs)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     edit
inputs:   ?
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    edit versus reference CDR3
page:     enclone help cvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     exact_subclonotype_id
inputs:   ?
limits:
class:    lvar
level:    exact
val:      positive_integer
doc:      TBD
brief:    identifier of exact subclonotype
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     filter
inputs:   ?
limits:
class:    lvar
level:    cell
val:      string
doc:      TBD
brief:    name of filter that would be applied (if filters off)
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     fwr{1..4}_aa
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    FWR* amino acid sequence
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          let c;
          if arg1 == 1 {
              c = get_fwr1(&x);
          } else if arg1 == 2 {
              c = get_fwr2(&x);
          } else if arg1 == 3 {
              c = get_fwr3(&x);
          } else {
              let x = &ex.share[mid];
              let start = rsi.cdr3_starts[col] + 3 * rsi.cdr3_lens[col];
              let stop = rsi.seq_del_lens[col];
              let dna = &x.seq_del_amino[start..stop];
              c = Some(stringme(&dna));
          }
          if c.is_some() {
              y = stringme(&aa_seq(c.unwrap().as_bytes(), 0));
          }
          y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     fwr{1..4}_aa_ref
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    FWR* amino acid seq for universal reference
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          if arg1 == 1 {
              if x.cdr1_start.is_some() && x.fr1_start <= x.cdr1_start.unwrap() {
                  let dna = refdata.refs[x.v_ref_id].to_ascii_vec()[x.fr1_start..x.cdr1_start
                      .unwrap()]
                      .to_vec();
                  y = stringme(&aa_seq(&dna, 0));
              }
          } else if arg1 == 2 {
              if x.fr2_start.unwrap() <= x.cdr2_start.unwrap() {
                  let dna = refdata.refs[x.v_ref_id].to_ascii_vec()
                      [x.fr2_start.unwrap()..x.cdr2_start.unwrap()]
                      .to_vec();
                  y = stringme(&aa_seq(&dna, 0));
              }
          } else if arg1 == 3 {
              if x.fr3_start.is_some() && x.fr3_start.unwrap() <= x.cdr3_start - x.ins_len() {
                  let dna = refdata.refs[x.v_ref_id].to_ascii_vec();
                  if x.cdr3_start <= dna.len() {
                      let dna = dna[x.fr3_start.unwrap()..x.cdr3_start - x.ins_len()].to_vec();
                      y = stringme(&aa_seq(&dna, 0));
                  }
              }
          } else {
              let heavy = refdata.rtype[x.j_ref_id] == 0;
              let aa_len;
              if heavy {
                  aa_len = 10;
              } else {
                  aa_len = 9;
              }
              let dna = refdata.refs[x.j_ref_id].to_ascii_vec();
              let dna = dna[dna.len() - 1 - 3 * aa_len..dna.len() - 1].to_vec();
              y = stringme(&aa_seq(&dna, 0));
          }
          y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     fwr{1..4}_dna
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    FWR* nucleotide sequence
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          let c;
          if arg1 == 1 {
              c = get_fwr1(&x);
          } else if arg1 == 2 {
              c = get_fwr2(&x);
          } else if arg1 == 3 {
              c = get_fwr3(&x);
          } else {
              let x = &ex.share[mid];
              let start = rsi.cdr3_starts[col] + 3 * rsi.cdr3_lens[col];
              let stop = rsi.seq_del_lens[col];
              let dna = &x.seq_del_amino[start..stop];
              c = Some(stringme(&dna));
          }
          if c.is_some() {
              y = c.unwrap();
          }
          y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     fwr{1..4}_dna_ref
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    FWR* nucleotide seq for universal reference
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          if arg1 == 1 {
              if x.cdr1_start.is_some() && x.fr1_start <= x.cdr1_start.unwrap() {
                  let dna = refdata.refs[x.v_ref_id].to_ascii_vec()[x.fr1_start..x.cdr1_start
                      .unwrap()]
                      .to_vec();
                  y = stringme(&dna);
              }
          } else if arg1 == 2 {
              if x.fr2_start.unwrap() <= x.cdr2_start.unwrap() {
                  let dna = refdata.refs[x.v_ref_id].to_ascii_vec()
                      [x.fr2_start.unwrap()..x.cdr2_start.unwrap()]
                      .to_vec();
                  y = stringme(&dna);
              }
          } else if arg1 == 3 {
              if x.fr3_start.is_some() && x.fr3_start.unwrap() <= x.cdr3_start - x.ins_len() {
                  let dna = refdata.refs[x.v_ref_id].to_ascii_vec();
                  if x.cdr3_start <= dna.len() {
                      let dna = dna[x.fr3_start.unwrap()..x.cdr3_start - x.ins_len()].to_vec();
                      y = stringme(&dna);
                  }
              }
          } else {
              let heavy = refdata.rtype[x.j_ref_id] == 0;
              let aa_len;
              if heavy {
                  aa_len = 10;
              } else {
                  aa_len = 9;
              }
              let dna = refdata.refs[x.j_ref_id].to_ascii_vec();
              let dna = dna[dna.len() - 1 - 3 * aa_len..dna.len() - 1].to_vec();
              y = stringme(&dna);
          }
          y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     fwr{1..4}_len
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    length of FWR* nucleotide sequence
page:     enclone help cvars
avail:    public
notes:
code:     let x = &ex.share[mid];
          let mut y = "unknown".to_string();
          let c;
          if arg1 == 1 {
              c = get_fwr1(&x);
          } else if arg1 == 2 {
              c = get_fwr2(&x);
          } else if arg1 == 3 {
              c = get_fwr3(&x);
          } else {
              let x = &ex.share[mid];
              let start = rsi.cdr3_starts[col] + 3 * rsi.cdr3_lens[col];
              let stop = rsi.seq_del_lens[col];
              let dna = &x.seq_del_amino[start..stop];
              c = Some(stringme(&dna));
          }
          if c.is_some() {
              y = format!("{}", c.unwrap().len() / 3);
          }
          y
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     gex
inputs:   ?
limits:
class:    lvar
level:    cell-exact
val:      float
doc:      TBD
brief:    median number of GEX UMIs
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     gex_cell
inputs:   ?
limits:
class:    lvar
level:    cell
val:      nonnegative_integer
doc:      TBD
brief:    number of GEX UMIs
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     gex_max
inputs:   ?
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    maximum number of GEX UMIs across exact subclonotype
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     gex_mean
inputs:   ?
limits:
class:    lvar
level:    exact
val:      float
doc:      TBD
brief:    mean of GEX UMIs across exact subclonotype (= <code>gex_μ</code>)
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     gex_min
inputs:   ?
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    minimum number of GEX UMIs across exact subclonotype 
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     gex_sum
inputs:   ?
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    sum of GEX UMIs across exact subclonotype (= <code>gex_Σ</code>) 
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     gex_Σ
inputs:   ?
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    sum of GEX UMIs across exact subclonotype (= <code>gex_sum</code>)
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     gex_μ
inputs:   ?
limits:
class:    lvar
level:    exact
val:      float
doc:      TBD
brief:    mean of GEX UMIs across exact subclonotype (= <code>gex_mean</code>)
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     group_id
inputs:   ?
limits:   only implemented for parseable output
class:    lvar
level:    group
val:      positive_integer
doc:      TBD
brief:    identifier of clonotype group
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     group_ncells
inputs:   ?
limits:   only implemented for parseable output
class:    lvar
level:    group
val:      positive_integer
doc:      TBD
brief:    number of cells in clonotype group
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     g{0,...}
inputs:   ?
limits:
class:    lvar
level:    exact
val:      positive_integer
doc:      TBD
brief:    exact subclonotype group, by Hamming distance
page:     enclone help lvars
avail:    public
notes:    0,... or 1,... and is it positive_integer or nonnegative_integer?
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     inkt
inputs:   ?
limits:
class:    lvar
level:    exact
val:      string
doc:      TBD
brief:    evidence for iNKT cell 
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     j_id
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      positive_integer
doc:      TBD
brief:    J region id
page:     enclone help parseable
avail:    public
notes:
code:     format!("{}", refdata.id[rsi.jids[col]])
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     j_name
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    J region name
page:     enclone help parseable
avail:    public
notes:
code:     refdata.name[rsi.jids[col]].clone()
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     mait
inputs:   ?
limits:
class:    lvar
level:    exact
val:      string
doc:      TBD
brief:    evidence for MAIT cell 
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     n
inputs:   ?
limits:   <code>PER_CELL</code> values are not displayed because they are all <code>1</code>, 
          which would be distracting; also there is no <code>_cell</code> version
class:    lvar
level:    cell-exact
val:      positive_integer
doc:      TBD
brief:    number of cells
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     n_NAME
inputs:   ?
limits:   <code>PER_CELL</code>values are not displayed because they are all <code>1</code>,
          which would be distracting; also there is no <code>_cell</code> version</td></tr>
class:    lvar
level:    cell-exact
val:      nonnegative_integer
doc:      TBD
brief:    number of cells associated to the given name
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     n_gex
inputs:   ?
limits:
class:    lvar
level:    cell-exact
val:      float
doc:      TBD
brief:    median number of cells seen by GEX pipeline
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     n_gex_cell
inputs:   ?
limits:
class:    lvar
level:    cell
val:      positive_integer
doc:      TBD
brief:    number of cells seen by GEX pipeline
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     nchains
inputs:   ?
limits:
class:    lvar
level:    clono
val:      positive_integer
doc:      TBD
brief:    number of chains in the clonotype
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     nchains_present
inputs:   ?
limits:
class:    lvar
level:    exact
val:      positive_integer
doc:      The number of chains that are present in a given exact subclonotype.
brief:    number of chains present in an exact subclonotype
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     ndiff{1..}vj
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    number of base differences with exact subclonotype of that number
page:     enclone help cvars
avail:    public
notes:
code:     let mat = &rsi.mat;
          let u0 = arg1 - 1;
          if u0 < exacts.len() && mat[col][u0].is_some() && mat[col][u].is_some() {
              let m0 = mat[col][u0].unwrap();
              let m = mat[col][u].unwrap();
              let mut ndiff = 0;
              let ex0 = &exact_clonotypes[exacts[u0]];
              let ex = &exact_clonotypes[exacts[u]];
              for p in 0..ex0.share[m0].seq_del.len() {
                  if ex0.share[m0].seq_del[p] != ex.share[m].seq_del[p] {
                      ndiff += 1;
                  }
              }
              format!("{}", ndiff)
          } else {
              "_".to_string()
          }
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     near
inputs:   varmat, fp, u
limits:
class:    lvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    Hamming distance to nearest neighbor 
page:     enclone help lvars
avail:    public
notes:
code:     let mut dist = 1_000_000;
          for i2 in 0..varmat.len() {
              if i2 == u || fp[i2] != fp[u] {
                  continue;
              }
              let mut d = 0;
              for c in fp[u].iter() {
                  for j in 0..varmat[u][*c].len() {
                      if varmat[u][*c][j] != varmat[i2][*c][j] {
                          d += 1;
                      }
                  }
              }
              dist = min(dist, d);
          }
          if dist == 1_000_000 {
              "".to_string()
          } else {
              format!("{}", dist)
          }
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     notes
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    notes for exact subclonotype
page:     enclone help cvars
avail:    public
notes:
code:     ex.share[mid].vs_notesx.clone()
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     origins
inputs:   ?
limits:
class:    lvar
level:    cell-exact
val:      string
doc:      TBD
brief:    origin names
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     origins_cell
inputs:   ?
limits:
class:    lvar
level:    cell
val:      string
doc:      TBD
brief:    origin name
page:     enclone help lvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     q{0,...}_
inputs:   ?
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    read quality scores at position <code>n</code>
page:     enclone help parseable
avail:    public
notes:    Should position start at 0 or 1?
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     r
inputs:   ?
limits:
class:    cvar
level:    cell-exact
val:      float
doc:      TBD
brief:    median number of reads supporting chain
page:     enclone help cvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     r_cell
inputs:   ?
limits:
class:    cvar
level:    cell
val:      nonnegative_integer
doc:      TBD
brief:    number of reads supporting chain
page:     enclone help cvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     r_max
inputs:   ?
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    maximum chain read count across exact subclonotype
page:     enclone help cvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     r_mean
inputs:   ?
limits:
class:    cvar
level:    exact
val:      float
doc:      TBD
brief:    mean chain reads across exact subclonotype (= <code>r_μ</code>)
page:     enclone help cvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     r_min
inputs:   ?
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    minimum chain read count across exact subclonotype
page:     enclone help cvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     r_sum
inputs:   ?
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    sum of chain read counts across exact subclonotype (= <code>r_Σ</code>)
page:     enclone help cvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     r_Σ
inputs:   ?
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    sum of chain reads across exact subclonotype (= <code>r_sum</code>)
page:     enclone help cvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     r_μ
inputs:   ?
limits:
class:    cvar
level:    exact
val:      float
doc:      TBD
brief:    mean chain read count across exact subclonotype (= <code>r_μ</code>)
page:     enclone help cvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     seq
inputs:   ?
limits:   only implemented for parseable output
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    full nucleotide sequence of exact subclonotype
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     share_indices_aa
inputs:   ?
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    shared amino acid positions
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     share_indices_dna
inputs:   ?
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    shared nucleotide positions
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     u
inputs:   ex, mid
limits:
class:    cvar
level:    cell-exact
val:      nonnegative_integer
doc:      TBD
brief:    median number of UMIs supporting chain
page:     enclone help cvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     u_cell
inputs:   ex, mid
limits:
class:    cvar
level:    cell
val:      nonnegative_integer
doc:      TBD
brief:    number of UMIs supporting chain
page:     enclone help cvars
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     u_max
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      For a chain in an exact subclonotype, the maximum number of UMIs, ranging across the 
          cells.
brief:    maximum chain UMIs across exact subclonotype
page:     enclone help cvars
avail:    public
notes:
code:     let mut numis = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              numis.push(ex.clones[j][mid].umi_count);
          }
          numis.sort();
          format!("{}", numis.iter().max().unwrap())
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     u_mean
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      float
doc:      TBD
brief:    mean chain UMIs across exact subclonotype (= <code>u_μ</code>) 
page:     enclone help cvars
avail:    public
notes:
code:     let mut numis = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              numis.push(ex.clones[j][mid].umi_count);
          }
          numis.sort();
          let utot: usize = numis.iter().sum();
          let u_mean = (utot as f64 / numis.len() as f64).round() as usize;
          format!("{}", u_mean)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     u_min
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    minimum chain UMIs across exact subclonotype
page:     enclone help cvars
avail:    public
notes:
code:     let mut numis = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              numis.push(ex.clones[j][mid].umi_count);
          }
          numis.sort();
          format!("{}", numis.iter().min().unwrap())
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     u_sum
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    sum of chain UMIs for exact subclonotype (= <code>u_Σ</code>)
page:     enclone help cvars
avail:    public
notes:
code:     let mut numis = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              numis.push(ex.clones[j][mid].umi_count);
          }
          let utot: usize = numis.iter().sum();
          format!("{}", utot)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     u_Σ
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    sum of chain UMIs across exact subclonotype (= <code>u_sum</code>)
page:     enclone help cvars
avail:    public
notes:
code:     let mut numis = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              numis.push(ex.clones[j][mid].umi_count);
          }
          let utot: usize = numis.iter().sum();
          format!("{}", utot)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     u_μ
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      float
doc:      TBD
brief:    mean chain UMIs for exact subclonotype (= <code>u_mean</code>)
page:     enclone help cvars
avail:    public
notes:
code:     let mut numis = Vec::<usize>::new();
          for j in 0..ex.clones.len() {
              numis.push(ex.clones[j][mid].umi_count);
          }
          numis.sort();
          let utot: usize = numis.iter().sum();
          let u_mean = (utot as f64 / numis.len() as f64).round() as usize;
          format!("{}", u_mean)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     udiff
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    differences of 5'-UTR region with universal reference
page:     enclone help cvars
avail:    public
notes:
code:     let ulen = ex.share[mid].v_start;
          let uid = ex.share[mid].u_ref_id;
          let mut udiff = String::new();
          let mut ndiffs = 0;
          if uid.is_some() {
              let r = &refdata.refs[uid.unwrap()];
              let mut extra = 0;
              if ulen > r.len() {
                  extra = ulen - r.len();
              }
              for i in 0..ulen {
                  let mut rpos = i;
                  if ulen < r.len() {
                      rpos += r.len() - ulen;
                  } else {
                      if i + r.len() < ulen {
                          continue;
                      }
                      rpos -= ulen - r.len();
                  }
                  let tb = ex.share[mid].full_seq[i];
                  let rb = r.to_ascii_vec()[rpos];
                  if tb != rb {
                      ndiffs += 1;
                      if ndiffs <= 5 {
                          udiff += &format!("{}{}", rpos, tb as char);
                      }
                  }
              }
              if ndiffs > 5 {
                  udiff += "...";
              }
              if extra > 0 {
                  udiff += &format!("+{}", extra);
              }
          } else if ulen > 0 {
              udiff = format!("+{}", ulen);
          }
          udiff
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     ulen
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      nonnegative_integer
doc:      TBD
brief:    length of observed 5'-UTR sequence 
page:     enclone help cvars
avail:    public
notes:
code:     format!("{}", ex.share[mid].v_start)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     utr_id
inputs:   ex, mid, refdata
limits:
class:    cvar
level:    exact
val:      positive_integer
doc:      TBD
brief:    numerical identifier of 5'-UTR region (or null)
page:     enclone help parseable
avail:    public
notes:
code:     let mut u = String::new();
          let uid = ex.share[mid].u_ref_id;
          if uid.is_some() {
              u = format!("{}", refdata.id[uid.unwrap()]);
          }
          u
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     utr_name
inputs:   ex, mid, refdata
limits:
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    name of 5'-UTR region (or null)
page:     enclone help parseable
avail:    public
notes:
code:     let mut u = String::new();
          let uid = ex.share[mid].u_ref_id;
          if uid.is_some() {
              u = refdata.name[uid.unwrap()].clone();
          }
          u
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     v_id
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      positive_integer
doc:      TBD
brief:    V region id
page:     enclone help parseable
avail:    public
notes:
code:     format!("{}", refdata.id[rsi.vids[col]])
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     v_name
inputs:   cvar_vdj
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    V region name
page:     enclone help parseable
avail:    public
notes:
code:     refdata.name[rsi.vids[col]].clone()
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     v_start
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      positive_integer_or_null
doc:      TBD
brief:    start of V on full nucleotide sequence
page:     enclone help parseable
avail:    public
notes:    Positive integer, or nonnegative integer?
code:     format!("{}", ex.share[mid].v_start)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     var
inputs:   varmat, u, col
limits:
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    bases at position in chain that vary across the clonotype
page:     enclone help cvars
avail:    public
notes:
code:     stringme(&varmat[u][col])
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     var_aa
inputs:   ?
limits:   only implemented for parseable output
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    variant residue indices in clonotype (including synonymous)
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     var_indices_aa
inputs:   ?
limits:   only implemented for parseable output
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    variable amino acid positions
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     var_indices_dna
inputs:   ?
limits:   only implemented for parseable output
class:    cvar
level:    clono
val:      string
doc:      TBD
brief:    variable nucleotide positions
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     vj_aa
inputs:   ?
limits:   only implemented for parseable output
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    amino acid sequence of V..J
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     vj_aa_nl
inputs:   ?
limits:   only implemented for parseable output
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    amino acid sequence of V..J, excluding leader
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     vj_seq
inputs:   ?
limits:   only implemented for parseable output
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    nucleotide sequence of V..J
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     vj_seq_nl
inputs:   ?
limits:   only implemented for parseable output
class:    cvar
level:    exact
val:      string
doc:      TBD
brief:    nucleotide sequence of V..J, excluding leader
page:     enclone help parseable
avail:    public
notes:
code:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
name:     vjlen
inputs:   cvar_vdj
limits:
class:    cvar
level:    exact
val:      positive_integer
doc:      TBD
brief:    length in bases of V..J
page:     enclone help cvars
avail:    public
notes:
code:     format!("{}", ex.share[mid].j_stop - ex.share[mid].v_start)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
