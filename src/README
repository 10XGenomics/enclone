// Copyright (c) 2020 10X Genomics, Inc. All rights reserved.
//
// enclone internal documentation
//
// This documentation is very dated.  Please do not rely on any information here.  Most of what
// is shown below consists of unsupported options that may or may not work.
//
// Usage: enclone x1 x2 ... xn <optional args>
//
// Each xi is a comma-separated list of datasets from a single donor.  Ranges e.g. 91200-91210
// are accepted.
//
// Each list of datasets is specified as a list of lena ids, or paths to outs folders.
// Do not include datasets which share essentially the same barcode sets, as would arise
// if those datasets were obtained from the same GEMs.
//
// Optional arguments may be supplied on the command line or via environment variables that are
// prefaced with "ENCLONE_".  As an example, setting the environment variable "ENCLONE_PRE" to
// "/usr/mcgoo/10x" would be equivalent to having "PRE=/use/mcgoo/10x" on the command line.
//
// Undocumented option: if an argument is a nonnegative integer, it is treated as if specified by
// TCR= or BCR=, but without setting one of them.
//
// Undocumented option: inclusive ranges l1-l2 of lena ids are expanded out.
//
// Optional arguments governing input and output files:
// - EXFASTA=f: dump fasta file f for V..J exact subclonotypes.
//
// Optional arguments that control basic execution:
// - HAPS=n: profile using count n; however to actually use this you need to temporarily
//           modify the code to replace all instances of par_iter_mut by iter_mut
// - CTRLC: traceback on control-C
// - COMP: show computational performance.
//
// Optional arguments controlling printing of join events:
// - SEQ: print sequences of contigs, before truncation to V..J
// - ANN: print annotations of contig
// - ANN0: print annotations of contig, after truncation to V..J
// - PFREQ=n: show data for 1/n joins even if correct
// - BC: show barcodes
// - PRINT_FAILED_JOINS: print failed join events.
//
// Optional arguments that control clonotype filtering:
// (see also "enclone help filter")
// - WHITEF: only show clonotypes that exhibit whitelist contamination
// - PROTECT_BADS: don't delete putatively bad stuff [internal for now]
// - FAIL_ONLY=true or false: only print failed clonotypes in the true case
// - VDUP: only show clonotypes having two chains with the same V segment
// - HAVE_ONESIE: only show clonotypes including a onesie exact subclonotype

// Optional arguments that control printing of individual clonotypes:
// - GEX: see above
//   There is an undocument option:
//   - white   = percent of sequences implicated in whitelist expansion.
// - CHAIN_BRIEF: show abbreviated chain column headers
// - DEBUG_TABLE_PRINTING: add print lines to help debug printing of tables.
// - NOTE_SIMPLE: note if the first sequence for the chain is simple, in the sense that it exactly 
//                equals the concatenation of the right-truncated V with the full J segment.
//
// Optional arguments that control miscellaneous logging:
// - DESCRIP: print sample descriptions
// - REUSE: print barcode reuse (that might arise from index hopping)
// - EXACT=n: print some data about exact subclonotype n.
//
// Optional arguments controlling logging for alternate alleles:
// - CON: print alternate consensus sequences
// - CON_TRACE: tracing for CON.
//
// Optional arguments that control the joining algorithm:
// - MAX_SCORE: to document
// - MIN_MULT: to document
// - MIN_ALT: to document
// - EASY: do not impose special condition on two cell joins
// - BCJOIN: substitute an algorithm that joins by barcode identity and ignores everything
//           else -- only useful for studying two datasets from the same GEM well that used
//           different enrichment protocols.
//
// Other optional arguments:
// - FORCE: make joins even if redundant
// - EXP: exploratory code for exact clonotyping on
// - WEAK: for EXP, print all and show weaks
// - GRAPH: show logging from light-heavy graph construction
// - UTR_CON: run experimental UTR consensus code
// - NOPAR: turn off parallelization
// - CON_CON: run experimental constant region consensus code
// - NSILENT: turn on extra logging
// - RE: reannotate instead of using the annotation in the json file, useful for two purposes:
//       1. If you have a json file generated by an outdated code version;
//       2. You want to see the effect of changed annotation code.
// - ONESIE_MULT=n: for a onesie exact subclonotype to be created, its number of cells must be at
//                  least 1/n of the total number of cells in exact subclonotypes; by default
//                  n = 10,000.  Lowering the value of this will increase the number of onesie
//                  exact subclonotypes, but increase the fraction that are incorrect.
// - NPLAIN: reverses PLAIN
// - INDELS: search for SHM indels (exploratory)
// - INSERTIONS: search for SHM insertions (exploratory)
// - NOPRETTY: turn off pretty trace entirely
// - HEAVY_CHAIN_REUSE: look for instances of heavy chain reuse
// - BINARY=filename: generate binary output file
// - PROTO=filename: generate proto output file
// - NH5: do not get gene expression values from the h5 file
// - NO_REUSE: exit if significant barcode reuse found, intended to detect accidental inclusion
//             of multiple datasets from the same cDNA from the same GEM well
// - DUMP_LENAS: special option to dump the list of lena ids and exit.
//
// - TOY: toy with phylogeny
//
// PROTECT_BADS
//
// EMAIL: name for email address (default enclone)
//
// EXT=filename:
// Given output of an external clonotyping algorithm which took as inputs the pipeline outputs 
// for the lenas in enclone.testdata, for each exact subclonotype found by enclone, report its 
// composition in the external clonotyping, as clonotype_id[count], ...
// The input file should have lines of the form:
// lena barcode clonotype_id.
//
// REQUIRED_FPS=n: exit(1) if the number of false positives is not n; here we define a false
// positive to be a clonotype that contains cells from multiple donors.
//
// For each VDJ dataset, the following files are used:
// - all_contig_annotations.json
// - _invocation.
//
// enclone.test
//    Run a full test on ~450 lenas, which takes about a minute.
//    For this you need cellranger/lib/rust/enclone/src in your path.
//    By default does not print clonotypes.  It just shows errors.  You can add enclone arguments.
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// The documentation below is out of date.
//
// The algorithm:
// 1.  For each clonotype, we recompute annotations of its contigs "from scratch".  The 
//     reference sequence for this consists of our usual VDJ reference plus a small number
//     of manual additions.
// 2.  For each of these contigs we find the inferred V..J sequence, extending from the 
//     beginning of the V to the end of the J.  Henceforth this is called the contig.
// 3.  The V and J reference sequences for a given contig are taken from the reference,
//     except in the special case where the V annotation shows one indel.  In that case,
//     the V reference sequence is edited either to delete or insert sequence.  In the
//     insertion case, the bases are taken from the contig.
// 4.  We consider pairs of clonotypes.  The rest of the algorithm concerns whether these 
//     should be joined.  We only consider clonotypes having two or three contigs.  The case
//     of four contigs is clearly harder because some are cell doublets.  Clonotypes having
//     three contigs are split into two overlapping sub-clonotypes.
// 5.  The contigs for the two clonotypes must have the same lengths and the total number
//     of mismatch positions between them must be at most 50.
// 6.  We compute the number of CDR3 diffs between the two clonotypes.  We reject the join if
//     the lengths are not equal.  Otherwise we compute the total number of differences 
//     between the two strings.
// 7.  We compute the number of "shared" mutations and the number of "independent" 
//     mutations.  A mutation is shared if both contigs for a given chain have the same 
//     base at a position, and that base disagrees with the reference.
// 8.  Otherwise, if a contig base disagrees with the reference, that counts as an
//     independent mutation.
// 9.  This is summed over the V and the J, where we compare starting at the beginning
//     for the V, and starting at the end for the J.  In both cases we exclude the
//     "last" 15 bases from the comparison.
// 10. These computations are carried out twice, once using the reference sequences for 
//     the first clonotype and once using the reference sequences for the second clonotype.
// 11. If the number of CDR3 diffs exceeds half the minimum of two shared mutation counts,
//     we reject the join.
//
// For given datasets, the algorithm is scored, yielding two numbers:
// - the number of joins
// - the number of incorrect joins, where a join is incorrect if it joins clonotypes
//   originating from two donors.
//
// More joins are better, less incorrect joins are better.  This can be used to choose 
// between two algorithms.  However the fraction of incorrect joins is a dubious metric,
// as it depends on non-meaningful characteristics of the data.  In particular, if the
// list for a given donor includes multiple datasets, there may be many easy joins between
// identical clonotypes lying in different datasets.  Possibly if we excluded these the
// fraction of incorrect joins would be a usable metric.
//
// A known case of false positive errors are V segments that are missing from our VDJ 
// reference.
//
// COMPUTATIONAL PERFORMANCE
// The bulk of the time is spent in the call to annotate_seq and in the line that counts the
// number of differences between two contigs.
//
// TO DO
// - Test for duplicate barcode should be made more specific, preferably by adding CDR3 info.
// - Ask for more files to be retained by evaporation, going forward.
// - Search for more lenas to add to test.
// - Run the positive control.
// - Allow four contigs.
// - Use reject contigs to increase power.
// - Fix problem: using original clonotypes based on CDR3 match is wrong.
// - Don't hardwire for human.
// - Arguably clonotypes from the same donors and different lenas and having the same CDR3s 
//   should be merged.  The problem with doing this is tracking, because then you can't say 
//   that a particular clonotype
// - Don't fix size for stirling2_ratio_table_f64.
// - What do we do for mixed BCR/TCR samples?
