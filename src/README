// Copyright (c) 2020 10X Genomics, Inc. All rights reserved.
//
// enclone internal documentation
//
// For each VDJ dataset, the following files are used:
// - all_contig_annotations.json
// - _invocation.
//
// enclone.test
//    Run a full test on ~450 lenas, which takes about a minute.
//    For this you need cellranger/lib/rust/enclone/src in your path.
//    By default does not print clonotypes.  It just shows errors.  You can add enclone arguments.
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// The documentation below is out of date.
//
// The algorithm:

// 6.  We compute the number of CDR3 diffs between the two clonotypes.  We reject the join if
//     the lengths are not equal.  Otherwise we compute the total number of differences 
//     between the two strings.
// 7.  We compute the number of "shared" mutations and the number of "independent" 
//     mutations.  A mutation is shared if both contigs for a given chain have the same 
//     base at a position, and that base disagrees with the reference.
// 8.  Otherwise, if a contig base disagrees with the reference, that counts as an
//     independent mutation.
// 9.  This is summed over the V and the J, where we compare starting at the beginning
//     for the V, and starting at the end for the J.  In both cases we exclude the
//     "last" 15 bases from the comparison.
// 10. These computations are carried out twice, once using the reference sequences for 
//     the first clonotype and once using the reference sequences for the second clonotype.
// 11. If the number of CDR3 diffs exceeds half the minimum of two shared mutation counts,
//     we reject the join.
//
// For given datasets, the algorithm is scored, yielding two numbers:
// - the number of joins
// - the number of incorrect joins, where a join is incorrect if it joins clonotypes
//   originating from two donors.
//
// More joins are better, less incorrect joins are better.  This can be used to choose 
// between two algorithms.  However the fraction of incorrect joins is a dubious metric,
// as it depends on non-meaningful characteristics of the data.  In particular, if the
// list for a given donor includes multiple datasets, there may be many easy joins between
// identical clonotypes lying in different datasets.  Possibly if we excluded these the
// fraction of incorrect joins would be a usable metric.
//
// A known case of false positive errors are V segments that are missing from our VDJ 
// reference.
//
// COMPUTATIONAL PERFORMANCE
// The bulk of the time is spent in the call to annotate_seq and in the line that counts the
// number of differences between two contigs.
//
// TO DO
// - Test for duplicate barcode should be made more specific, preferably by adding CDR3 info.
// - Ask for more files to be retained by evaporation, going forward.
// - Search for more lenas to add to test.
// - Run the positive control.
// - Allow four contigs.
// - Use reject contigs to increase power.
// - Fix problem: using original clonotypes based on CDR3 match is wrong.
// - Don't hardwire for human.
// - Arguably clonotypes from the same donors and different lenas and having the same CDR3s 
//   should be merged.  The problem with doing this is tracking, because then you can't say 
//   that a particular clonotype
// - Don't fix size for stirling2_ratio_table_f64.
